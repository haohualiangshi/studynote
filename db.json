{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b56af3e39dfabb94391b3e422f644494fb1d3962","modified":1543237692000},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1543206768000},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1543206768000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1543206768000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1543206768000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1543206768000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1543206768000},{"_id":"source/_drafts/oo.md","hash":"d580c4f009470c518b3fc15019f5fefa34f74d43","modified":1543206768000},{"_id":"source/_posts/blogOfHexo.md","hash":"04ad0fb39eb0696f43d96beeec1a9d3521b34b9f","modified":1543206768000},{"_id":"source/_posts/es5-ver.md","hash":"dd1828c04b35905c8307c5e6eb64f7f8a6892908","modified":1543206768000},{"_id":"source/_posts/es5-ver2-md.md","hash":"bc29e4cc4e4728f30e38604d89ce4d1ab0cc540e","modified":1543206768000},{"_id":"source/_posts/fundation-01.md","hash":"d5d25114d2f3dd6933aeeeceec1d8d4e8ee301a5","modified":1544062035000},{"_id":"source/_posts/note-taking-01.md","hash":"8c58bec1692d2b2630c1dc65b2b7acdcee491a04","modified":1543206768000},{"_id":"source/_posts/referenceType-1.md","hash":"72580853979eefa2865de52b71e5383c301d11fd","modified":1543206768000},{"_id":"source/_posts/前端知识点汇总.md","hash":"271ddf5627e453286c56098c75b470a50496e287","modified":1543206768000},{"_id":"source/_posts/ios-c-note.md","hash":"231191eb3409938999ce2db5821c1abd7e9a520e","modified":1544152914000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1543206768000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1543206768000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1543206768000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1543206768000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1543206768000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1543206768000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1543206768000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1543206768000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1543206768000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1543206768000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1543206768000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1543206768000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1543206768000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1543206768000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1543206768000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1543206768000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543206768000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543206768000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1543206768000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1543206768000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1543206768000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1543206768000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1543206768000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1543206768000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1543206768000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1543206768000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1543206768000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1543206768000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1543206768000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1543206768000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1543206768000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1543206768000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1543206768000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1543206768000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1543206768000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543206768000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1543206768000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1543206768000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1543206768000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1543206768000},{"_id":"public/2018/11/25/fundation-01/index.html","hash":"9b0d6cbe86609051544ed1e23763e6d69d846d0e","modified":1544152938077},{"_id":"public/2017/07/05/es5-ver2-md/index.html","hash":"9694bae9cfb8490a7407343427ee7d87e2a12448","modified":1544152938077},{"_id":"public/2017/07/04/es5-ver/index.html","hash":"f9404eec273601771a47a7008fb83c2004db66d2","modified":1544152938077},{"_id":"public/2017/06/30/blogOfHexo/index.html","hash":"3b8a1f48b57674c13558633f2277e9872f6a45dd","modified":1544152938078},{"_id":"public/archives/index.html","hash":"4efcdef429c0342c83f72b062766383e04d4b809","modified":1544152938078},{"_id":"public/archives/2017/index.html","hash":"1675bf75ff4eaaad4b9b0a599eb8fc0df27fb93c","modified":1544152938078},{"_id":"public/archives/2017/06/index.html","hash":"e4a3075a0c44f190f73de6604abf200589d0a197","modified":1544152938078},{"_id":"public/archives/2017/07/index.html","hash":"657b8b840c0300ad7abfa46943d0d95cdf4d7eae","modified":1544152938078},{"_id":"public/archives/2018/index.html","hash":"ee9eca3cd5ce1024ce168650836194712ceec916","modified":1544152938078},{"_id":"public/archives/2018/11/index.html","hash":"9e3bef5016327c578d42fb053fc10540736ef4df","modified":1544152938078},{"_id":"public/categories/搭建博客/index.html","hash":"276831f0cd5718e1dd5bfc2aa69cfe6a8d5c8193","modified":1544152938079},{"_id":"public/categories/js教程总结/index.html","hash":"c56a921d03e8efa99928c01aa73dd50c0facb018","modified":1544152938079},{"_id":"public/categories/随手笔记/index.html","hash":"fbf2a8e65c8624c79978c8e3dff6f8506cc72bbf","modified":1544152938079},{"_id":"public/categories/总结/index.html","hash":"1f29b34089f3f4f95014b816cb5ca6daa08d4d1c","modified":1544152938079},{"_id":"public/tags/tool/index.html","hash":"d84233ea7fd577fded16cf19e351080b3a430752","modified":1544152938079},{"_id":"public/tags/hexo/index.html","hash":"fa4f6da1fa4c982009ae4e925f739e7bf6b3bee4","modified":1544152938079},{"_id":"public/tags/js/index.html","hash":"90ec1b59731bcca4551cf92e11cd3d079bc46857","modified":1544152938079},{"_id":"public/tags/变量/index.html","hash":"582c10f9dabe893b88a9184b89f2a36ceaa374e8","modified":1544152938079},{"_id":"public/tags/作用域/index.html","hash":"cfaff95325e2a10dd984d154385cb88b2a4e4dc7","modified":1544152938080},{"_id":"public/tags/blob/index.html","hash":"2069ed0a36f082ea04fd7ecad44311f55de652ce","modified":1544152938080},{"_id":"public/tags/引用类型/index.html","hash":"61a4923ee007cf7ccca261e8d0e7cfd8ebbc79a3","modified":1544152938080},{"_id":"public/tags/html/index.html","hash":"1c5fa04451886a934a8a9524a43d7c31ad540bef","modified":1544152938080},{"_id":"public/2017/07/31/前端知识点汇总/index.html","hash":"31d0557993fb92810a576c82db17cf9f8685acdc","modified":1544152938080},{"_id":"public/2017/07/10/note-taking-01/index.html","hash":"d69848a1dcb19e118fa07f41f86ee858580eef3c","modified":1544152938080},{"_id":"public/2017/07/06/referenceType-1/index.html","hash":"e122273cbb211ac9e50c2606d8191305c987030d","modified":1544152938081},{"_id":"public/index.html","hash":"3f4bdb53ad71a0b48ea1717259bc0aeaefda779e","modified":1544152938081},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1544152938086},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1544152938086},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1544152938086},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1544152938086},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1544152938086},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1544152938087},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1544152938087},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1544152938087},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1544152938087},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1544152938087},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1544152939775},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1544152939781},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1544152939781},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1544152939781},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1544152939781},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1544152939781},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1544152939781},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1544152939781},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1544152939781},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1544152939782},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1544152939782},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1544152939785},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1544152939785}],"Category":[{"name":"搭建博客","_id":"cjpdgsewp0002ybf7epx9rndr"},{"name":"js教程总结","_id":"cjpdgsewz0007ybf7psw936qr"},{"name":"随手笔记","_id":"cjpdgsex7000hybf7xlhwql9t"},{"name":"总结","_id":"cjpdgsex9000lybf7d3pwx6ie"}],"Data":[],"Page":[],"Post":[{"title":"blogOfHexo","date":"2017-06-30T10:48:35.000Z","_content":"\n## 博客搭建教程\n\n>    参考链接：<https://smartbeng.github.io/2017/03/26/blogFinish/>\n\n1.   安装Node.js\\Git。并在git上创建仓库：<https://github.com/haohualiangshi/haohualiangshi.github.io>，要求仓库名必须和用户名相同。即必须是userName.github.io;我的userName是haohualiangshi\n2.   安装Hexo工具\n     1.   在任意盘创建Hexo文件（必须是Hexo文件命名）；在Hexo文件夹的父级打开git命令行；运行`$ npm install -g hexo `;\n     2.   打开Hexo文件夹；运行`hexo init`\n     3.   运行`hexo g`用来生成页面；运行`heox s`启动本地服务\n     4.   hexo 常用命令\n          1.   `hexo new page \"pageName\"`新建文件夹。自动生成在source目录下\n\n          2.   `hexo new \"postName\"`新建md文件；在source下的_post目录下；\n\n          3.   hexo运行的命令生成的页面文件是放在public文件夹下；新建一个文件夹用来往github上推送本地的文件。eg:我本地新建的是.deploy文件夹；克隆仓库文件,在hexo目录下运行`git clone https://github.com/haohualiangshi/haohualiangshi.github.io .deploy/storm.git.github.io`或者打开storm.git.github.io文件夹直接执行复制指令\n\n          4.    ~~~\n               hexo clean\n               hexo generate\n               cp -R public/* .deploy/storm.github.io\n               git add .\n               git commit -m \"update\"\n               git push origin master -u\n                ~~~\n\n               1.   将上边文件类型命名为.sh文件类型；点击之后自动完成写入的指令完成上传；代码的意思：清除缓存、生成静态文件、将静态文件中的所有文件复制到.deploy/storm.github.io文件夹下、完成git的添加上传；\n\n3.   关于主题的更换网上的文件比较多；我使用的是next主题；参考的教程<http://theme-next.iissnan.com/getting-started.html>\n\n\n","source":"_posts/blogOfHexo.md","raw":"---\ntitle: blogOfHexo\ndate: 2017-06-30 18:48:35\ntags: [tool,hexo]\ncategories: 搭建博客\n---\n\n## 博客搭建教程\n\n>    参考链接：<https://smartbeng.github.io/2017/03/26/blogFinish/>\n\n1.   安装Node.js\\Git。并在git上创建仓库：<https://github.com/haohualiangshi/haohualiangshi.github.io>，要求仓库名必须和用户名相同。即必须是userName.github.io;我的userName是haohualiangshi\n2.   安装Hexo工具\n     1.   在任意盘创建Hexo文件（必须是Hexo文件命名）；在Hexo文件夹的父级打开git命令行；运行`$ npm install -g hexo `;\n     2.   打开Hexo文件夹；运行`hexo init`\n     3.   运行`hexo g`用来生成页面；运行`heox s`启动本地服务\n     4.   hexo 常用命令\n          1.   `hexo new page \"pageName\"`新建文件夹。自动生成在source目录下\n\n          2.   `hexo new \"postName\"`新建md文件；在source下的_post目录下；\n\n          3.   hexo运行的命令生成的页面文件是放在public文件夹下；新建一个文件夹用来往github上推送本地的文件。eg:我本地新建的是.deploy文件夹；克隆仓库文件,在hexo目录下运行`git clone https://github.com/haohualiangshi/haohualiangshi.github.io .deploy/storm.git.github.io`或者打开storm.git.github.io文件夹直接执行复制指令\n\n          4.    ~~~\n               hexo clean\n               hexo generate\n               cp -R public/* .deploy/storm.github.io\n               git add .\n               git commit -m \"update\"\n               git push origin master -u\n                ~~~\n\n               1.   将上边文件类型命名为.sh文件类型；点击之后自动完成写入的指令完成上传；代码的意思：清除缓存、生成静态文件、将静态文件中的所有文件复制到.deploy/storm.github.io文件夹下、完成git的添加上传；\n\n3.   关于主题的更换网上的文件比较多；我使用的是next主题；参考的教程<http://theme-next.iissnan.com/getting-started.html>\n\n\n","slug":"blogOfHexo","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsewe0000ybf70xjk7450","content":"<h2 id=\"博客搭建教程\"><a href=\"#博客搭建教程\" class=\"headerlink\" title=\"博客搭建教程\"></a>博客搭建教程</h2><blockquote>\n<p>   参考链接：<a href=\"https://smartbeng.github.io/2017/03/26/blogFinish/\" target=\"_blank\" rel=\"noopener\">https://smartbeng.github.io/2017/03/26/blogFinish/</a></p>\n</blockquote>\n<ol>\n<li>安装Node.js\\Git。并在git上创建仓库：<a href=\"https://github.com/haohualiangshi/haohualiangshi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/haohualiangshi/haohualiangshi.github.io</a>，要求仓库名必须和用户名相同。即必须是userName.github.io;我的userName是haohualiangshi</li>\n<li><p>安装Hexo工具</p>\n<ol>\n<li>在任意盘创建Hexo文件（必须是Hexo文件命名）；在Hexo文件夹的父级打开git命令行；运行<code>$ npm install -g hexo</code>;</li>\n<li>打开Hexo文件夹；运行<code>hexo init</code></li>\n<li>运行<code>hexo g</code>用来生成页面；运行<code>heox s</code>启动本地服务</li>\n<li><p>hexo 常用命令</p>\n<ol>\n<li><p><code>hexo new page &quot;pageName&quot;</code>新建文件夹。自动生成在source目录下</p>\n</li>\n<li><p><code>hexo new &quot;postName&quot;</code>新建md文件；在source下的_post目录下；</p>\n</li>\n<li><p>hexo运行的命令生成的页面文件是放在public文件夹下；新建一个文件夹用来往github上推送本地的文件。eg:我本地新建的是.deploy文件夹；克隆仓库文件,在hexo目录下运行<code>git clone https://github.com/haohualiangshi/haohualiangshi.github.io .deploy/storm.git.github.io</code>或者打开storm.git.github.io文件夹直接执行复制指令</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* .deploy/storm.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;update&quot;</span><br><span class=\"line\">git push origin master -u</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将上边文件类型命名为.sh文件类型；点击之后自动完成写入的指令完成上传；代码的意思：清除缓存、生成静态文件、将静态文件中的所有文件复制到.deploy/storm.github.io文件夹下、完成git的添加上传；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>关于主题的更换网上的文件比较多；我使用的是next主题；参考的教程<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com/getting-started.html</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"博客搭建教程\"><a href=\"#博客搭建教程\" class=\"headerlink\" title=\"博客搭建教程\"></a>博客搭建教程</h2><blockquote>\n<p>   参考链接：<a href=\"https://smartbeng.github.io/2017/03/26/blogFinish/\" target=\"_blank\" rel=\"noopener\">https://smartbeng.github.io/2017/03/26/blogFinish/</a></p>\n</blockquote>\n<ol>\n<li>安装Node.js\\Git。并在git上创建仓库：<a href=\"https://github.com/haohualiangshi/haohualiangshi.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/haohualiangshi/haohualiangshi.github.io</a>，要求仓库名必须和用户名相同。即必须是userName.github.io;我的userName是haohualiangshi</li>\n<li><p>安装Hexo工具</p>\n<ol>\n<li>在任意盘创建Hexo文件（必须是Hexo文件命名）；在Hexo文件夹的父级打开git命令行；运行<code>$ npm install -g hexo</code>;</li>\n<li>打开Hexo文件夹；运行<code>hexo init</code></li>\n<li>运行<code>hexo g</code>用来生成页面；运行<code>heox s</code>启动本地服务</li>\n<li><p>hexo 常用命令</p>\n<ol>\n<li><p><code>hexo new page &quot;pageName&quot;</code>新建文件夹。自动生成在source目录下</p>\n</li>\n<li><p><code>hexo new &quot;postName&quot;</code>新建md文件；在source下的_post目录下；</p>\n</li>\n<li><p>hexo运行的命令生成的页面文件是放在public文件夹下；新建一个文件夹用来往github上推送本地的文件。eg:我本地新建的是.deploy文件夹；克隆仓库文件,在hexo目录下运行<code>git clone https://github.com/haohualiangshi/haohualiangshi.github.io .deploy/storm.git.github.io</code>或者打开storm.git.github.io文件夹直接执行复制指令</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">cp -R public/* .deploy/storm.github.io</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;update&quot;</span><br><span class=\"line\">git push origin master -u</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将上边文件类型命名为.sh文件类型；点击之后自动完成写入的指令完成上传；代码的意思：清除缓存、生成静态文件、将静态文件中的所有文件复制到.deploy/storm.github.io文件夹下、完成git的添加上传；</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>关于主题的更换网上的文件比较多；我使用的是next主题；参考的教程<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">http://theme-next.iissnan.com/getting-started.html</a></p>\n</li>\n</ol>\n"},{"title":"es5-ver","date":"2017-07-04T06:52:19.000Z","_content":"\n## 变量、作用域\n\n### 变量\n\n1.   js的变量是松散类型的，即可以用来保存任何类型的数据\n\n2.   变量分为**5**种基本数据类型和**1**种复杂类型的：\n     1.   基本类型：Undefined、Null、Boolean、Number和String\n     2.   复杂类型：Object，Object本质上是由一组**无序**的名值对组成\n\n3.   在es 5中是可以使用**typeof操作符**进行数据类型的检测，其返回值：undefined、boolean、string、number、object、function。\n\n4.   在使用数值转换时的三种方法\n     1.   Number()函数的转换规则，在传入值不同下返回;\n          *    boolean值的true和false直接转换为1和0\n          *    数值直接返回传入值\n          *    null值返回0\n          *    undefined返回NaN\n          *    字符串：\n               1.   字符串全为数字；将该字符串转为十进制；eg;\"123\"转为123，“0123”转为123\n               2.   如果字符串包含浮点格式“1.5”转为浮点值1.5，同样忽略前边的0；但是如果不是标准的浮点格式；会转为NaN;\n               3.   如果字符串是标准的十六进制格式“0xaf”则转为十进制175\n               4.   字符串为空转为0\n               5.   其他不符合该规则的字符串转为NaN\n          *    对象：传入值是对象先调用valueof()方法；依照上述规则转换\n     2.   parseInt()函数容错比Number函数高；解析时如果第一个字符不是数字或者正负号，该函数会返回一个NaN，该函数第二个参数用来表示装换时使用的基数\n     3.   parseFloat()函数在在解析一个没有小数点或者小数点后全为零的字符点时返回的是个整数；\n\n5.   字符串生成后时不可变的；null和undefined不具有toString()方法。可以使用String()方法；在数值调用toString方法可以传参数用来指定在转换时的基数；\n\n6.   js中的对象其实就是一组数据和功能的集合：object的每个实例都具有下列属性和方法\n\n     1.   constructor：保存着用于创建当前对象的函数\n     2.   hasOwnProperty(propertyName)用于检测给定的属性在当前实例对象中是否存在；而不是在实例的原型中\n     3.   isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型；\n     4.   toLocaleString()\n     5.   toString()\n     6.   valueOf()\n\n7.   操作符\n\n     1.   一元操作符：有前置型和后置型；这4个操作符对任何值都适用\n     2.   逻辑非操作符(!)：遵循规则\n          *    操作数是对象；返回false\n          *    操作数的空字符串返回true\n          *    非空字符串返回false\n          *    0返回true；非0数值返回false\n          *    null、undefined、NaN返回true\n     3.   逻辑与(&&)，具有短路效应，即第一个操作数能够决定结果，那么不会对第二个操作数求值；逻辑与操作可以应用任何类型的操作数；而不仅仅是一个布尔值；在有一个操作数不是布尔值的情况下；逻辑与的返回值不一定是布尔值；遵循规则如下：\n          *    第一个操作数是对象；返回第二个操作数\n          *    在第一个操作数逻辑值为true时返回第二个操作数，否则返回第一个操作数\n     4.   逻辑或(||),逻辑或也是短路操作符，第一个操作数为true就不会对第二个操作数求值；如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值\n     5.   关系操作符：关系操作符分为小于(<)、大于、小于等于、大于等于，在使用关系操作符时注意隐式转换\n          *    数值的优先级比较高；如果一个操作数是字符串或者布尔值和一个数值比较；则先将字符串转为数值，注意：该转换方法调用的是Number()方法；然后进行比较；如果一个操作数是对象，则先调用valueof方法，没有valueof方法则调用toString方法\n          *    当两个操作数都是都是字符串；则表两个字符中对应位置的字符的字符编码值\n          *    **任何操作数与NaN比较都是false** \n     6.   相等操作符：相等和不相等、全等和不全等\n          1.   相等和不相等是先转换再比较，，称为**强制转型** ，其规则与比较运算符区别如下\n               *    null和undefined相等，如果两个操作数都是对象；则比较这两个对象是不是指向的同一个对象\n          2.   全等和不全等（===、!==）不转换就进行比较，类型和值全部相等才返回true\n\n     ### 函数\n\n     函数的参数在内部是用一个伪数组arguments表示的；函数的length属性是表示形参的个数；arguments.length表示实参的个数；在js中函数没有才重载；函数在未指定返回值的情况下默认返回undefined","source":"_posts/es5-ver.md","raw":"---\ntitle: es5-ver\ndate: 2017-07-04 14:52:19\ntags: [js,变量,作用域]\ncategories: js教程总结\n---\n\n## 变量、作用域\n\n### 变量\n\n1.   js的变量是松散类型的，即可以用来保存任何类型的数据\n\n2.   变量分为**5**种基本数据类型和**1**种复杂类型的：\n     1.   基本类型：Undefined、Null、Boolean、Number和String\n     2.   复杂类型：Object，Object本质上是由一组**无序**的名值对组成\n\n3.   在es 5中是可以使用**typeof操作符**进行数据类型的检测，其返回值：undefined、boolean、string、number、object、function。\n\n4.   在使用数值转换时的三种方法\n     1.   Number()函数的转换规则，在传入值不同下返回;\n          *    boolean值的true和false直接转换为1和0\n          *    数值直接返回传入值\n          *    null值返回0\n          *    undefined返回NaN\n          *    字符串：\n               1.   字符串全为数字；将该字符串转为十进制；eg;\"123\"转为123，“0123”转为123\n               2.   如果字符串包含浮点格式“1.5”转为浮点值1.5，同样忽略前边的0；但是如果不是标准的浮点格式；会转为NaN;\n               3.   如果字符串是标准的十六进制格式“0xaf”则转为十进制175\n               4.   字符串为空转为0\n               5.   其他不符合该规则的字符串转为NaN\n          *    对象：传入值是对象先调用valueof()方法；依照上述规则转换\n     2.   parseInt()函数容错比Number函数高；解析时如果第一个字符不是数字或者正负号，该函数会返回一个NaN，该函数第二个参数用来表示装换时使用的基数\n     3.   parseFloat()函数在在解析一个没有小数点或者小数点后全为零的字符点时返回的是个整数；\n\n5.   字符串生成后时不可变的；null和undefined不具有toString()方法。可以使用String()方法；在数值调用toString方法可以传参数用来指定在转换时的基数；\n\n6.   js中的对象其实就是一组数据和功能的集合：object的每个实例都具有下列属性和方法\n\n     1.   constructor：保存着用于创建当前对象的函数\n     2.   hasOwnProperty(propertyName)用于检测给定的属性在当前实例对象中是否存在；而不是在实例的原型中\n     3.   isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型；\n     4.   toLocaleString()\n     5.   toString()\n     6.   valueOf()\n\n7.   操作符\n\n     1.   一元操作符：有前置型和后置型；这4个操作符对任何值都适用\n     2.   逻辑非操作符(!)：遵循规则\n          *    操作数是对象；返回false\n          *    操作数的空字符串返回true\n          *    非空字符串返回false\n          *    0返回true；非0数值返回false\n          *    null、undefined、NaN返回true\n     3.   逻辑与(&&)，具有短路效应，即第一个操作数能够决定结果，那么不会对第二个操作数求值；逻辑与操作可以应用任何类型的操作数；而不仅仅是一个布尔值；在有一个操作数不是布尔值的情况下；逻辑与的返回值不一定是布尔值；遵循规则如下：\n          *    第一个操作数是对象；返回第二个操作数\n          *    在第一个操作数逻辑值为true时返回第二个操作数，否则返回第一个操作数\n     4.   逻辑或(||),逻辑或也是短路操作符，第一个操作数为true就不会对第二个操作数求值；如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值\n     5.   关系操作符：关系操作符分为小于(<)、大于、小于等于、大于等于，在使用关系操作符时注意隐式转换\n          *    数值的优先级比较高；如果一个操作数是字符串或者布尔值和一个数值比较；则先将字符串转为数值，注意：该转换方法调用的是Number()方法；然后进行比较；如果一个操作数是对象，则先调用valueof方法，没有valueof方法则调用toString方法\n          *    当两个操作数都是都是字符串；则表两个字符中对应位置的字符的字符编码值\n          *    **任何操作数与NaN比较都是false** \n     6.   相等操作符：相等和不相等、全等和不全等\n          1.   相等和不相等是先转换再比较，，称为**强制转型** ，其规则与比较运算符区别如下\n               *    null和undefined相等，如果两个操作数都是对象；则比较这两个对象是不是指向的同一个对象\n          2.   全等和不全等（===、!==）不转换就进行比较，类型和值全部相等才返回true\n\n     ### 函数\n\n     函数的参数在内部是用一个伪数组arguments表示的；函数的length属性是表示形参的个数；arguments.length表示实参的个数；在js中函数没有才重载；函数在未指定返回值的情况下默认返回undefined","slug":"es5-ver","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsewm0001ybf7iw74vhuu","content":"<h2 id=\"变量、作用域\"><a href=\"#变量、作用域\" class=\"headerlink\" title=\"变量、作用域\"></a>变量、作用域</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ol>\n<li><p>js的变量是松散类型的，即可以用来保存任何类型的数据</p>\n</li>\n<li><p>变量分为<strong>5</strong>种基本数据类型和<strong>1</strong>种复杂类型的：</p>\n<ol>\n<li>基本类型：Undefined、Null、Boolean、Number和String</li>\n<li>复杂类型：Object，Object本质上是由一组<strong>无序</strong>的名值对组成</li>\n</ol>\n</li>\n<li><p>在es 5中是可以使用<strong>typeof操作符</strong>进行数据类型的检测，其返回值：undefined、boolean、string、number、object、function。</p>\n</li>\n<li><p>在使用数值转换时的三种方法</p>\n<ol>\n<li>Number()函数的转换规则，在传入值不同下返回;<ul>\n<li>boolean值的true和false直接转换为1和0</li>\n<li>数值直接返回传入值</li>\n<li>null值返回0</li>\n<li>undefined返回NaN</li>\n<li>字符串：<ol>\n<li>字符串全为数字；将该字符串转为十进制；eg;”123”转为123，“0123”转为123</li>\n<li>如果字符串包含浮点格式“1.5”转为浮点值1.5，同样忽略前边的0；但是如果不是标准的浮点格式；会转为NaN;</li>\n<li>如果字符串是标准的十六进制格式“0xaf”则转为十进制175</li>\n<li>字符串为空转为0</li>\n<li>其他不符合该规则的字符串转为NaN</li>\n</ol>\n</li>\n<li>对象：传入值是对象先调用valueof()方法；依照上述规则转换</li>\n</ul>\n</li>\n<li>parseInt()函数容错比Number函数高；解析时如果第一个字符不是数字或者正负号，该函数会返回一个NaN，该函数第二个参数用来表示装换时使用的基数</li>\n<li>parseFloat()函数在在解析一个没有小数点或者小数点后全为零的字符点时返回的是个整数；</li>\n</ol>\n</li>\n<li><p>字符串生成后时不可变的；null和undefined不具有toString()方法。可以使用String()方法；在数值调用toString方法可以传参数用来指定在转换时的基数；</p>\n</li>\n<li><p>js中的对象其实就是一组数据和功能的集合：object的每个实例都具有下列属性和方法</p>\n<ol>\n<li>constructor：保存着用于创建当前对象的函数</li>\n<li>hasOwnProperty(propertyName)用于检测给定的属性在当前实例对象中是否存在；而不是在实例的原型中</li>\n<li>isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型；</li>\n<li>toLocaleString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ol>\n</li>\n<li><p>操作符</p>\n<ol>\n<li>一元操作符：有前置型和后置型；这4个操作符对任何值都适用</li>\n<li>逻辑非操作符(!)：遵循规则<ul>\n<li>操作数是对象；返回false</li>\n<li>操作数的空字符串返回true</li>\n<li>非空字符串返回false</li>\n<li>0返回true；非0数值返回false</li>\n<li>null、undefined、NaN返回true</li>\n</ul>\n</li>\n<li>逻辑与(&amp;&amp;)，具有短路效应，即第一个操作数能够决定结果，那么不会对第二个操作数求值；逻辑与操作可以应用任何类型的操作数；而不仅仅是一个布尔值；在有一个操作数不是布尔值的情况下；逻辑与的返回值不一定是布尔值；遵循规则如下：<ul>\n<li>第一个操作数是对象；返回第二个操作数</li>\n<li>在第一个操作数逻辑值为true时返回第二个操作数，否则返回第一个操作数</li>\n</ul>\n</li>\n<li>逻辑或(||),逻辑或也是短路操作符，第一个操作数为true就不会对第二个操作数求值；如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值</li>\n<li>关系操作符：关系操作符分为小于(&lt;)、大于、小于等于、大于等于，在使用关系操作符时注意隐式转换<ul>\n<li>数值的优先级比较高；如果一个操作数是字符串或者布尔值和一个数值比较；则先将字符串转为数值，注意：该转换方法调用的是Number()方法；然后进行比较；如果一个操作数是对象，则先调用valueof方法，没有valueof方法则调用toString方法</li>\n<li>当两个操作数都是都是字符串；则表两个字符中对应位置的字符的字符编码值</li>\n<li><strong>任何操作数与NaN比较都是false</strong> </li>\n</ul>\n</li>\n<li>相等操作符：相等和不相等、全等和不全等<ol>\n<li>相等和不相等是先转换再比较，，称为<strong>强制转型</strong> ，其规则与比较运算符区别如下<ul>\n<li>null和undefined相等，如果两个操作数都是对象；则比较这两个对象是不是指向的同一个对象</li>\n</ul>\n</li>\n<li>全等和不全等（===、!==）不转换就进行比较，类型和值全部相等才返回true</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数的参数在内部是用一个伪数组arguments表示的；函数的length属性是表示形参的个数；arguments.length表示实参的个数；在js中函数没有才重载；函数在未指定返回值的情况下默认返回undefined</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"变量、作用域\"><a href=\"#变量、作用域\" class=\"headerlink\" title=\"变量、作用域\"></a>变量、作用域</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ol>\n<li><p>js的变量是松散类型的，即可以用来保存任何类型的数据</p>\n</li>\n<li><p>变量分为<strong>5</strong>种基本数据类型和<strong>1</strong>种复杂类型的：</p>\n<ol>\n<li>基本类型：Undefined、Null、Boolean、Number和String</li>\n<li>复杂类型：Object，Object本质上是由一组<strong>无序</strong>的名值对组成</li>\n</ol>\n</li>\n<li><p>在es 5中是可以使用<strong>typeof操作符</strong>进行数据类型的检测，其返回值：undefined、boolean、string、number、object、function。</p>\n</li>\n<li><p>在使用数值转换时的三种方法</p>\n<ol>\n<li>Number()函数的转换规则，在传入值不同下返回;<ul>\n<li>boolean值的true和false直接转换为1和0</li>\n<li>数值直接返回传入值</li>\n<li>null值返回0</li>\n<li>undefined返回NaN</li>\n<li>字符串：<ol>\n<li>字符串全为数字；将该字符串转为十进制；eg;”123”转为123，“0123”转为123</li>\n<li>如果字符串包含浮点格式“1.5”转为浮点值1.5，同样忽略前边的0；但是如果不是标准的浮点格式；会转为NaN;</li>\n<li>如果字符串是标准的十六进制格式“0xaf”则转为十进制175</li>\n<li>字符串为空转为0</li>\n<li>其他不符合该规则的字符串转为NaN</li>\n</ol>\n</li>\n<li>对象：传入值是对象先调用valueof()方法；依照上述规则转换</li>\n</ul>\n</li>\n<li>parseInt()函数容错比Number函数高；解析时如果第一个字符不是数字或者正负号，该函数会返回一个NaN，该函数第二个参数用来表示装换时使用的基数</li>\n<li>parseFloat()函数在在解析一个没有小数点或者小数点后全为零的字符点时返回的是个整数；</li>\n</ol>\n</li>\n<li><p>字符串生成后时不可变的；null和undefined不具有toString()方法。可以使用String()方法；在数值调用toString方法可以传参数用来指定在转换时的基数；</p>\n</li>\n<li><p>js中的对象其实就是一组数据和功能的集合：object的每个实例都具有下列属性和方法</p>\n<ol>\n<li>constructor：保存着用于创建当前对象的函数</li>\n<li>hasOwnProperty(propertyName)用于检测给定的属性在当前实例对象中是否存在；而不是在实例的原型中</li>\n<li>isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型；</li>\n<li>toLocaleString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ol>\n</li>\n<li><p>操作符</p>\n<ol>\n<li>一元操作符：有前置型和后置型；这4个操作符对任何值都适用</li>\n<li>逻辑非操作符(!)：遵循规则<ul>\n<li>操作数是对象；返回false</li>\n<li>操作数的空字符串返回true</li>\n<li>非空字符串返回false</li>\n<li>0返回true；非0数值返回false</li>\n<li>null、undefined、NaN返回true</li>\n</ul>\n</li>\n<li>逻辑与(&amp;&amp;)，具有短路效应，即第一个操作数能够决定结果，那么不会对第二个操作数求值；逻辑与操作可以应用任何类型的操作数；而不仅仅是一个布尔值；在有一个操作数不是布尔值的情况下；逻辑与的返回值不一定是布尔值；遵循规则如下：<ul>\n<li>第一个操作数是对象；返回第二个操作数</li>\n<li>在第一个操作数逻辑值为true时返回第二个操作数，否则返回第一个操作数</li>\n</ul>\n</li>\n<li>逻辑或(||),逻辑或也是短路操作符，第一个操作数为true就不会对第二个操作数求值；如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值</li>\n<li>关系操作符：关系操作符分为小于(&lt;)、大于、小于等于、大于等于，在使用关系操作符时注意隐式转换<ul>\n<li>数值的优先级比较高；如果一个操作数是字符串或者布尔值和一个数值比较；则先将字符串转为数值，注意：该转换方法调用的是Number()方法；然后进行比较；如果一个操作数是对象，则先调用valueof方法，没有valueof方法则调用toString方法</li>\n<li>当两个操作数都是都是字符串；则表两个字符中对应位置的字符的字符编码值</li>\n<li><strong>任何操作数与NaN比较都是false</strong> </li>\n</ul>\n</li>\n<li>相等操作符：相等和不相等、全等和不全等<ol>\n<li>相等和不相等是先转换再比较，，称为<strong>强制转型</strong> ，其规则与比较运算符区别如下<ul>\n<li>null和undefined相等，如果两个操作数都是对象；则比较这两个对象是不是指向的同一个对象</li>\n</ul>\n</li>\n<li>全等和不全等（===、!==）不转换就进行比较，类型和值全部相等才返回true</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数的参数在内部是用一个伪数组arguments表示的；函数的length属性是表示形参的个数；arguments.length表示实参的个数；在js中函数没有才重载；函数在未指定返回值的情况下默认返回undefined</p>\n</li>\n</ol>\n"},{"title":"es5-ver2.md","date":"2017-07-05T09:04:50.000Z","_content":"\n## 变量的操作\n\n1.   在使用引用类型操作时；js不允许直接访问内存的的位置，也就是说不能直接操作对象的内存空间，在操作对象时是操作的对象的引用\n\n     *    复制基本类型的变量值时；会在变量对象上创建一个新值；然后把该值复制到新变量分配的位置上\n     *    复制引用类型时：其实是复制的副本的一个指针，该指针的指向与复制对象的指向相同\n\n     函数的参数都是按值传递的；即把函数外部的值复制给函数内部的参数；函数的参数其实就是函数的内部变量；\n\n     2.   变量的检测：基本类型的变量用typeof来检测类型；引用类型的需要使用instanceof来判断是不是一个对象的实例；基本类型的变量使用instanceof返回false；\n\n     ### 执行环境和作用域\n\n     执行环境定义了变量或者函数有权访问的其他数据，每一个执行环境都有一个与之关联的**变量对象** ；当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行代码所在环境的变量对象；如果执行环境是个函数，则将其活动对象作为变量对象，活动对象最开始只包括一个变量，即arguments对象。\n\n     作用域链中的下一个对象来自包含（外部）环境，再下一个变量对象怎来自下一个包含环境；一直延续到全局执行环境；全局执行环境的对象始终都是作用域链的最后一个对象。\n\n     ~~~javascript\n     var color=\"blue\";\n     function changeColors(){\n     \tvar anotherColor=\"red\";\n     \tfunction swapColors(){\n     \t\tvar tempColor=anotherColor;\n     \t\tanotherColor=color;\n     \t\tcolor=tempColor;\n     \t\t//三个变量都能访问到\n     \t}\n     \t//能访问两个变量\n     }\n     //只能访问全局变量\n     ~~~\n\n     内部函数可以通过作用域链访问外部函数的变量对象\n\n     1.   声明变量：使用var声明的变量会自动添加到最接近的环境中；如果再使用变量前未声明；该变量会被自动添加到全局环境；严格模式下初始化未声明的变量会报错。","source":"_posts/es5-ver2-md.md","raw":"---\ntitle: es5-ver2.md\ndate: 2017-07-05 17:04:50\ntags: [js,变量,作用域]\ncategories: js教程总结\n---\n\n## 变量的操作\n\n1.   在使用引用类型操作时；js不允许直接访问内存的的位置，也就是说不能直接操作对象的内存空间，在操作对象时是操作的对象的引用\n\n     *    复制基本类型的变量值时；会在变量对象上创建一个新值；然后把该值复制到新变量分配的位置上\n     *    复制引用类型时：其实是复制的副本的一个指针，该指针的指向与复制对象的指向相同\n\n     函数的参数都是按值传递的；即把函数外部的值复制给函数内部的参数；函数的参数其实就是函数的内部变量；\n\n     2.   变量的检测：基本类型的变量用typeof来检测类型；引用类型的需要使用instanceof来判断是不是一个对象的实例；基本类型的变量使用instanceof返回false；\n\n     ### 执行环境和作用域\n\n     执行环境定义了变量或者函数有权访问的其他数据，每一个执行环境都有一个与之关联的**变量对象** ；当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行代码所在环境的变量对象；如果执行环境是个函数，则将其活动对象作为变量对象，活动对象最开始只包括一个变量，即arguments对象。\n\n     作用域链中的下一个对象来自包含（外部）环境，再下一个变量对象怎来自下一个包含环境；一直延续到全局执行环境；全局执行环境的对象始终都是作用域链的最后一个对象。\n\n     ~~~javascript\n     var color=\"blue\";\n     function changeColors(){\n     \tvar anotherColor=\"red\";\n     \tfunction swapColors(){\n     \t\tvar tempColor=anotherColor;\n     \t\tanotherColor=color;\n     \t\tcolor=tempColor;\n     \t\t//三个变量都能访问到\n     \t}\n     \t//能访问两个变量\n     }\n     //只能访问全局变量\n     ~~~\n\n     内部函数可以通过作用域链访问外部函数的变量对象\n\n     1.   声明变量：使用var声明的变量会自动添加到最接近的环境中；如果再使用变量前未声明；该变量会被自动添加到全局环境；严格模式下初始化未声明的变量会报错。","slug":"es5-ver2-md","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsews0004ybf7nn90nyo1","content":"<h2 id=\"变量的操作\"><a href=\"#变量的操作\" class=\"headerlink\" title=\"变量的操作\"></a>变量的操作</h2><ol>\n<li><p>在使用引用类型操作时；js不允许直接访问内存的的位置，也就是说不能直接操作对象的内存空间，在操作对象时是操作的对象的引用</p>\n<ul>\n<li>复制基本类型的变量值时；会在变量对象上创建一个新值；然后把该值复制到新变量分配的位置上</li>\n<li>复制引用类型时：其实是复制的副本的一个指针，该指针的指向与复制对象的指向相同</li>\n</ul>\n<p>函数的参数都是按值传递的；即把函数外部的值复制给函数内部的参数；函数的参数其实就是函数的内部变量；</p>\n<ol start=\"2\">\n<li>变量的检测：基本类型的变量用typeof来检测类型；引用类型的需要使用instanceof来判断是不是一个对象的实例；基本类型的变量使用instanceof返回false；</li>\n</ol>\n<h3 id=\"执行环境和作用域\"><a href=\"#执行环境和作用域\" class=\"headerlink\" title=\"执行环境和作用域\"></a>执行环境和作用域</h3><p>执行环境定义了变量或者函数有权访问的其他数据，每一个执行环境都有一个与之关联的<strong>变量对象</strong> ；当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行代码所在环境的变量对象；如果执行环境是个函数，则将其活动对象作为变量对象，活动对象最开始只包括一个变量，即arguments对象。</p>\n<p>作用域链中的下一个对象来自包含（外部）环境，再下一个变量对象怎来自下一个包含环境；一直延续到全局执行环境；全局执行环境的对象始终都是作用域链的最后一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color=<span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColors</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> anotherColor=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> tempColor=anotherColor;</span><br><span class=\"line\">\t\tanotherColor=color;</span><br><span class=\"line\">\t\tcolor=tempColor;</span><br><span class=\"line\">\t\t<span class=\"comment\">//三个变量都能访问到</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//能访问两个变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//只能访问全局变量</span></span><br></pre></td></tr></table></figure>\n<p>内部函数可以通过作用域链访问外部函数的变量对象</p>\n<ol>\n<li>声明变量：使用var声明的变量会自动添加到最接近的环境中；如果再使用变量前未声明；该变量会被自动添加到全局环境；严格模式下初始化未声明的变量会报错。</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"变量的操作\"><a href=\"#变量的操作\" class=\"headerlink\" title=\"变量的操作\"></a>变量的操作</h2><ol>\n<li><p>在使用引用类型操作时；js不允许直接访问内存的的位置，也就是说不能直接操作对象的内存空间，在操作对象时是操作的对象的引用</p>\n<ul>\n<li>复制基本类型的变量值时；会在变量对象上创建一个新值；然后把该值复制到新变量分配的位置上</li>\n<li>复制引用类型时：其实是复制的副本的一个指针，该指针的指向与复制对象的指向相同</li>\n</ul>\n<p>函数的参数都是按值传递的；即把函数外部的值复制给函数内部的参数；函数的参数其实就是函数的内部变量；</p>\n<ol start=\"2\">\n<li>变量的检测：基本类型的变量用typeof来检测类型；引用类型的需要使用instanceof来判断是不是一个对象的实例；基本类型的变量使用instanceof返回false；</li>\n</ol>\n<h3 id=\"执行环境和作用域\"><a href=\"#执行环境和作用域\" class=\"headerlink\" title=\"执行环境和作用域\"></a>执行环境和作用域</h3><p>执行环境定义了变量或者函数有权访问的其他数据，每一个执行环境都有一个与之关联的<strong>变量对象</strong> ；当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行代码所在环境的变量对象；如果执行环境是个函数，则将其活动对象作为变量对象，活动对象最开始只包括一个变量，即arguments对象。</p>\n<p>作用域链中的下一个对象来自包含（外部）环境，再下一个变量对象怎来自下一个包含环境；一直延续到全局执行环境；全局执行环境的对象始终都是作用域链的最后一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color=<span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColors</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> anotherColor=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> tempColor=anotherColor;</span><br><span class=\"line\">\t\tanotherColor=color;</span><br><span class=\"line\">\t\tcolor=tempColor;</span><br><span class=\"line\">\t\t<span class=\"comment\">//三个变量都能访问到</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//能访问两个变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//只能访问全局变量</span></span><br></pre></td></tr></table></figure>\n<p>内部函数可以通过作用域链访问外部函数的变量对象</p>\n<ol>\n<li>声明变量：使用var声明的变量会自动添加到最接近的环境中；如果再使用变量前未声明；该变量会被自动添加到全局环境；严格模式下初始化未声明的变量会报错。</li>\n</ol>\n</li>\n</ol>\n"},{"title":"fundation-01","date":"2018-11-25T12:49:45.000Z","_content":"\n## 数字\n\n* Int:有符号整数值类型\n\n  * 返回指定范围内的随机值\n\n    ~~~swift\n    static func random(in range:<Range<Int>)->Int\n    // demo;随机生成100以内的随机数\n    for _ in 1...3{\n        print(Int.random(in:1..<100))\n        print(Int.random(in:1...100))\n    }\n    ~~~\n\n  * 同时计算除法的商和余数\n\n    ~~~swift\n    func quotientAndRemainder(dividingBy rhs:Int) -> (quotient:Int,remainder:Int)\n    //demo\n    let x = 1000000\n    let (q,r) = x.quotientAndRemainder(dividingBy:Int)//q==1071;r=757\n    ~~~\n\n  * 利用系统的URLComponents获取IOS中对应结构的元素\n\n    * 属性值\n\n      ~~~\n      public var scheme:String?\t协议\n      public var user:String?\n      public var password:String?\n      public var host:String?\t域名\n      public var port:String?\t端口\n      public var path:String?\t路径\n      public var query:String?\t参数\n      public var fragment:String?\n      public var queryItem:[URLQueryItem]?\t参数集合\n      ~~~\n\n\n  #### 字符串String\n\n  * 使用`\\()`可以快速的将其他类型转为字符串；可以使用`+`组合字符串；多行字符串使用`\"\"\"`三个双引号括起来\n  * 获取字符串中某一个元素的位置`string.firstIndex(of:\"\")??string.endIndex`\n  * `isEmpty:Bool`一个布尔值；表示集合是否为空；也可测试字符串是否为空；使用`count`获取字符创的长度\n  * 从文件或URL创建字符串`init(contentsOf:URL) 或者init(contentOfFile:String)`;使用`append(string/character)`将给定的字符或者字符串追加到字符串中\n  * 使用`insert(Character,at:String.Index)`将指定字符串插入到指定位置\n  * 替换子字符串`replaceSubrange`\n  * 删除子字符串\n    * `remove(at:String.Index) -> Character`删除并返回指定位置的字符\n    * `removeAll(keepingVapacity:Bool)`删除所有元素\n    * `removeAll(where:(character) -> Bool)`删除满足给定微词的左右元素\n\n#### 查找字符串\n\n* `hasPrefix(String)`返回一个布尔值；字符串是否以指定的前缀开头\n* `hasSuffix(string)`返回一个布尔值；指示字符串是否以指定的后缀结尾\n* `contains(Character)`返回一个布尔值；是否以指定的后缀结尾\n\n### 集合\n\n* 集合包含：数组Array/字典Dictionary/Set无序的独特元素集合\n* 数组：使用`isEmpty`判断数组是否为空；使用`first`和`last`属性安全访问第一个和最后一个元素的值；如果为空则为`nil`\n* `append(_:)`将单个元素添加到数组的末尾；`append(contentsOf:)`同时添加多个元素\n\n","source":"_posts/fundation-01.md","raw":"---\ntitle: fundation-01\ndate: 2018-11-25 20:49:45\ntags:\n---\n\n## 数字\n\n* Int:有符号整数值类型\n\n  * 返回指定范围内的随机值\n\n    ~~~swift\n    static func random(in range:<Range<Int>)->Int\n    // demo;随机生成100以内的随机数\n    for _ in 1...3{\n        print(Int.random(in:1..<100))\n        print(Int.random(in:1...100))\n    }\n    ~~~\n\n  * 同时计算除法的商和余数\n\n    ~~~swift\n    func quotientAndRemainder(dividingBy rhs:Int) -> (quotient:Int,remainder:Int)\n    //demo\n    let x = 1000000\n    let (q,r) = x.quotientAndRemainder(dividingBy:Int)//q==1071;r=757\n    ~~~\n\n  * 利用系统的URLComponents获取IOS中对应结构的元素\n\n    * 属性值\n\n      ~~~\n      public var scheme:String?\t协议\n      public var user:String?\n      public var password:String?\n      public var host:String?\t域名\n      public var port:String?\t端口\n      public var path:String?\t路径\n      public var query:String?\t参数\n      public var fragment:String?\n      public var queryItem:[URLQueryItem]?\t参数集合\n      ~~~\n\n\n  #### 字符串String\n\n  * 使用`\\()`可以快速的将其他类型转为字符串；可以使用`+`组合字符串；多行字符串使用`\"\"\"`三个双引号括起来\n  * 获取字符串中某一个元素的位置`string.firstIndex(of:\"\")??string.endIndex`\n  * `isEmpty:Bool`一个布尔值；表示集合是否为空；也可测试字符串是否为空；使用`count`获取字符创的长度\n  * 从文件或URL创建字符串`init(contentsOf:URL) 或者init(contentOfFile:String)`;使用`append(string/character)`将给定的字符或者字符串追加到字符串中\n  * 使用`insert(Character,at:String.Index)`将指定字符串插入到指定位置\n  * 替换子字符串`replaceSubrange`\n  * 删除子字符串\n    * `remove(at:String.Index) -> Character`删除并返回指定位置的字符\n    * `removeAll(keepingVapacity:Bool)`删除所有元素\n    * `removeAll(where:(character) -> Bool)`删除满足给定微词的左右元素\n\n#### 查找字符串\n\n* `hasPrefix(String)`返回一个布尔值；字符串是否以指定的前缀开头\n* `hasSuffix(string)`返回一个布尔值；指示字符串是否以指定的后缀结尾\n* `contains(Character)`返回一个布尔值；是否以指定的后缀结尾\n\n### 集合\n\n* 集合包含：数组Array/字典Dictionary/Set无序的独特元素集合\n* 数组：使用`isEmpty`判断数组是否为空；使用`first`和`last`属性安全访问第一个和最后一个元素的值；如果为空则为`nil`\n* `append(_:)`将单个元素添加到数组的末尾；`append(contentsOf:)`同时添加多个元素\n\n","slug":"fundation-01","published":1,"updated":"2018-12-06T02:07:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsewu0005ybf7xr0br2ds","content":"<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><ul>\n<li><p>Int:有符号整数值类型</p>\n<ul>\n<li><p>返回指定范围内的随机值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">(<span class=\"keyword\">in</span> range:&lt;Range&lt;Int&gt;)</span></span>-&gt;<span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">// demo;随机生成100以内的随机数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">3</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"type\">Int</span>.random(<span class=\"keyword\">in</span>:<span class=\"number\">1</span>..&lt;<span class=\"number\">100</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"type\">Int</span>.random(<span class=\"keyword\">in</span>:<span class=\"number\">1</span>...<span class=\"number\">100</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同时计算除法的商和余数</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quotientAndRemainder</span><span class=\"params\">(dividingBy rhs:Int)</span></span> -&gt; (quotient:<span class=\"type\">Int</span>,remainder:<span class=\"type\">Int</span>)</span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1000000</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> (q,r) = x.quotientAndRemainder(dividingBy:<span class=\"type\">Int</span>)<span class=\"comment\">//q==1071;r=757</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用系统的URLComponents获取IOS中对应结构的元素</p>\n<ul>\n<li><p>属性值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public var scheme:String?\t协议</span><br><span class=\"line\">public var user:String?</span><br><span class=\"line\">public var password:String?</span><br><span class=\"line\">public var host:String?\t域名</span><br><span class=\"line\">public var port:String?\t端口</span><br><span class=\"line\">public var path:String?\t路径</span><br><span class=\"line\">public var query:String?\t参数</span><br><span class=\"line\">public var fragment:String?</span><br><span class=\"line\">public var queryItem:[URLQueryItem]?\t参数集合</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串String\"><a href=\"#字符串String\" class=\"headerlink\" title=\"字符串String\"></a>字符串String</h4><ul>\n<li>使用<code>\\()</code>可以快速的将其他类型转为字符串；可以使用<code>+</code>组合字符串；多行字符串使用<code>&quot;&quot;&quot;</code>三个双引号括起来</li>\n<li>获取字符串中某一个元素的位置<code>string.firstIndex(of:&quot;&quot;)??string.endIndex</code></li>\n<li><code>isEmpty:Bool</code>一个布尔值；表示集合是否为空；也可测试字符串是否为空；使用<code>count</code>获取字符创的长度</li>\n<li>从文件或URL创建字符串<code>init(contentsOf:URL) 或者init(contentOfFile:String)</code>;使用<code>append(string/character)</code>将给定的字符或者字符串追加到字符串中</li>\n<li>使用<code>insert(Character,at:String.Index)</code>将指定字符串插入到指定位置</li>\n<li>替换子字符串<code>replaceSubrange</code></li>\n<li>删除子字符串<ul>\n<li><code>remove(at:String.Index) -&gt; Character</code>删除并返回指定位置的字符</li>\n<li><code>removeAll(keepingVapacity:Bool)</code>删除所有元素</li>\n<li><code>removeAll(where:(character) -&gt; Bool)</code>删除满足给定微词的左右元素</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"查找字符串\"><a href=\"#查找字符串\" class=\"headerlink\" title=\"查找字符串\"></a>查找字符串</h4><ul>\n<li><code>hasPrefix(String)</code>返回一个布尔值；字符串是否以指定的前缀开头</li>\n<li><code>hasSuffix(string)</code>返回一个布尔值；指示字符串是否以指定的后缀结尾</li>\n<li><code>contains(Character)</code>返回一个布尔值；是否以指定的后缀结尾</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><ul>\n<li>集合包含：数组Array/字典Dictionary/Set无序的独特元素集合</li>\n<li>数组：使用<code>isEmpty</code>判断数组是否为空；使用<code>first</code>和<code>last</code>属性安全访问第一个和最后一个元素的值；如果为空则为<code>nil</code></li>\n<li><code>append(_:)</code>将单个元素添加到数组的末尾；<code>append(contentsOf:)</code>同时添加多个元素</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><ul>\n<li><p>Int:有符号整数值类型</p>\n<ul>\n<li><p>返回指定范围内的随机值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">(<span class=\"keyword\">in</span> range:&lt;Range&lt;Int&gt;)</span></span>-&gt;<span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">// demo;随机生成100以内的随机数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">3</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"type\">Int</span>.random(<span class=\"keyword\">in</span>:<span class=\"number\">1</span>..&lt;<span class=\"number\">100</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"type\">Int</span>.random(<span class=\"keyword\">in</span>:<span class=\"number\">1</span>...<span class=\"number\">100</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同时计算除法的商和余数</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quotientAndRemainder</span><span class=\"params\">(dividingBy rhs:Int)</span></span> -&gt; (quotient:<span class=\"type\">Int</span>,remainder:<span class=\"type\">Int</span>)</span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1000000</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> (q,r) = x.quotientAndRemainder(dividingBy:<span class=\"type\">Int</span>)<span class=\"comment\">//q==1071;r=757</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用系统的URLComponents获取IOS中对应结构的元素</p>\n<ul>\n<li><p>属性值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public var scheme:String?\t协议</span><br><span class=\"line\">public var user:String?</span><br><span class=\"line\">public var password:String?</span><br><span class=\"line\">public var host:String?\t域名</span><br><span class=\"line\">public var port:String?\t端口</span><br><span class=\"line\">public var path:String?\t路径</span><br><span class=\"line\">public var query:String?\t参数</span><br><span class=\"line\">public var fragment:String?</span><br><span class=\"line\">public var queryItem:[URLQueryItem]?\t参数集合</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"字符串String\"><a href=\"#字符串String\" class=\"headerlink\" title=\"字符串String\"></a>字符串String</h4><ul>\n<li>使用<code>\\()</code>可以快速的将其他类型转为字符串；可以使用<code>+</code>组合字符串；多行字符串使用<code>&quot;&quot;&quot;</code>三个双引号括起来</li>\n<li>获取字符串中某一个元素的位置<code>string.firstIndex(of:&quot;&quot;)??string.endIndex</code></li>\n<li><code>isEmpty:Bool</code>一个布尔值；表示集合是否为空；也可测试字符串是否为空；使用<code>count</code>获取字符创的长度</li>\n<li>从文件或URL创建字符串<code>init(contentsOf:URL) 或者init(contentOfFile:String)</code>;使用<code>append(string/character)</code>将给定的字符或者字符串追加到字符串中</li>\n<li>使用<code>insert(Character,at:String.Index)</code>将指定字符串插入到指定位置</li>\n<li>替换子字符串<code>replaceSubrange</code></li>\n<li>删除子字符串<ul>\n<li><code>remove(at:String.Index) -&gt; Character</code>删除并返回指定位置的字符</li>\n<li><code>removeAll(keepingVapacity:Bool)</code>删除所有元素</li>\n<li><code>removeAll(where:(character) -&gt; Bool)</code>删除满足给定微词的左右元素</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"查找字符串\"><a href=\"#查找字符串\" class=\"headerlink\" title=\"查找字符串\"></a>查找字符串</h4><ul>\n<li><code>hasPrefix(String)</code>返回一个布尔值；字符串是否以指定的前缀开头</li>\n<li><code>hasSuffix(string)</code>返回一个布尔值；指示字符串是否以指定的后缀结尾</li>\n<li><code>contains(Character)</code>返回一个布尔值；是否以指定的后缀结尾</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><ul>\n<li>集合包含：数组Array/字典Dictionary/Set无序的独特元素集合</li>\n<li>数组：使用<code>isEmpty</code>判断数组是否为空；使用<code>first</code>和<code>last</code>属性安全访问第一个和最后一个元素的值；如果为空则为<code>nil</code></li>\n<li><code>append(_:)</code>将单个元素添加到数组的末尾；<code>append(contentsOf:)</code>同时添加多个元素</li>\n</ul>\n"},{"title":"note_taking_01","date":"2017-07-10T07:50:27.000Z","_content":"\n### 关于blob类型的理解\n\n想下载一个视频时发现是个blob:src形式；不明白这个是个什么鬼，以下是搜索学习的总结\n\n1.   参考网址：https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html  。先来段代码熟悉下意思\n\n     ~~~javascript\n     var video=document.querySelector('video');\n     var mediaSource=new MdeiaSource;\n     video.Src=URL.createObjectURL(mediaSource);\n     mediaSource.addEventListener('sourceopen',sourceOpen);\n     function sourceOpen(){\n       var mediaSource=this;\n       var sourceBuffer = mediaSource.addSourceBuffer('video/mp4';codecs=\"avc1.42E01E,mp4a.40.2\");\n     sourceBuffer.addEventListener('updateend',function(){\n       mediaSource.endOfStream();\n       video.play();\n     })\n     sourceBuffer.appendBuffer(buf);// buf is the arraybuffer to store the video data\n     }\n     ~~~\n\n     代码解析：创建变量名为video的DOM对象，创建变量名为mediaSource的MediaSource对象。通过函数createObjectURL将video对象的src和mediaSource进行连接，然后通过注册事件event::sourceopen来触发当前连接之后的的回调处理；回调处理就是需要赋值视频数据的地方，调用MediaSourceBuffer::addSourceBuffer方法来构建一个存放视频数据的Buffer；在往buffer中存放数据结束后触发事件updateend。然后调用play函数通知浏览器播放视频\n\n2.   MediaSource :mediaSource是Media Source Extensions API表示媒体资源HTMLMediaElement对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。\n     参考网址：https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource\n\n     MediaSource属性：\n\n     1.   MediaSource.sourceBuffers:**只读** ，返回一个SourceBufferList对象，包含了SourceBuffer的列表object associated with this MediaSource.\n     2.   MediaSource.activeSourceBuffer:**只读** \n     3.   MediaSource.readyState:只读\n     4.   mediaSource.duration\n\n     方法：\n\n     1.   addSourceBuffer():该事件是在触发sourceopen监听时进行的，该动作会创建一个sourceBuffer对象用于数据流的播放处理。如果mediaSource对象无法触发该事件；则无法通过该扩展进行播放的。\n     2.   removeSourceBuffer():\n     3.   endOfStream()\n\n3.   MediaSource接口的使用：\n\n     参考网址：http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79\n\n     1.   判断是否mediaSource的扩展类，该语句决定了整个播放方式是否可以使用MediaSource接口控制播放器。\n\n          ~~~javascript\n          window.MediaSource = window.MediaSource || window.WebkitMediaSource;\n          ~~~\n\n     2.   isTypeSupporteed:判断是否支持要解码播放的视频文件编码和类型。\n\n          ~~~javascript\n          MediaSource.isTypeSupported('video/webm;codecs=\"vorbis,vp8\"');//是否支持webm\n          MediaSource.isTypeSupported('video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"')//是否支持MP4\n          MediaSource.isTypeSupported('video/mp2t;codes=\"avc1.42E01E,mp4a.40.2\"')//是否支持ts\n          ~~~\n\n     3.   addSourceBuffer\n\n          ~~~javascript\n          mediaSource.addSourceBuffer('video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"')\n          ~~~\n\n     4.   appendBuffer:sourceBuffer对象的方法，用于持续数据的添加播放\n\n          ~~~javascript\n          sourceBuffer.appendBuffer(Uint8array);//媒体二进制数据\n          ~~~\n\n     5.   buffered: 类型为TimeRanges，描述了添加进去的所有媒体数据的range信息。为一个数组，里边标示了持续或间断的时间信息列表\n\n          ~~~javascript\n          for(var i=0;i<buffered.length;i++){\n            start=buffered.start(i)//第i个range信息的开始时间\n            end=buffered.end(i);//第i个range信息的结束时间\n          }\n          ~~~\n\n          如果播放的媒体数据是连续的；则只有一个开始时间点和一个结束时间点。所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算\n\n          ~~~javascript\n          function play(){\n            if(!this.mediaSource){\n              this.mediaSource=new MediaSource();\n              var me=this;\n              this.mediaSource.addEventListener(\"sourceopen\",function(){\n                me.onMediaSourceOpen();\n              });\n              this.mediaSource.addEventListener(\"sourceended\",function(){\n                me.onMediaSourceEnded();\n              });\n              this.mediaSource.addEventListener('sourceclose',function(){\n                me.onMediaSourceClose();\n              });\n              this.mediaSource.addEventListener(\"error\",function(){\n                me.onUpdataError();\n              });\n              this.video=this.createNewVideo();\n              this.video.src=window.URL.createObjectURL(this.mediaSource);\n              this.video.play();\n            }\n            if(!this.sourceBuffer){\n              return ;\n            }\n            if(this.sourceBuffer.updating){\n              return;//上一块数据还在添加中\n            }\n            try{\n              this.sourceBuffer.appendBuffer(dataBytes);//添加数据\n            }catch(err){}\n          }\n            function createNewVideo(){\n              var newVideo=document.createElement(\"video\");\n              newVideo.id=\"player\";\n              newVideo.width=this.videoWidth;\n              newVideo.height=this.videoHeight;\n              return newVideo;\n            }\n            //事件侦听\n            onMediaSourceOpen:function(){\n              //DOMString可以通过转码获得\n              var typeNmae='video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"';\n              var issurpport=MediaSource.isTypeSupported(typeName);\n              this.mediaSource.duration=this.totalDuration;//设置视频总时长\n              this.sourceBuffer=this.mediaSource.addSourceBuffer(typeName);\n            }\n            onMediaSourceEnded:function(){\n              console.log(\"source ended\");\n            }\n            onMediaSourceClosed:function(){\n              console.log(\"cource close\");\n            }\n          }\n          ~~~\n\n4.   以下是自己做的一个demo；MP4格式的文件未成功；webm格式的成功了；但是不能跨越\n\n     ~~~\n     <!DOCTYPE html>\n     <html>\n\n     \t<head>\n     \t\t<meta charset=\"UTF-8\">\n     \t\t<title>blob</title>\n     \t</head>\n\n     \t<body>\n     \t\t<video id=\"video\" controls=\"controls\"></video>\n     \t\t<script type=\"text/javascript\">\n     \t\t\tvar video = document.querySelector('video');\n     \t\t\tvar assetURL = 'http://172.16.70.106:8020/Demo/Demo1/audio/test2.webm';\n     \t\t\t// Need to be specific for Blink regarding codecs\n     \t\t\t// ./mp4info frag_bunny.mp4 | grep Codec\n     \t\t\tvar mimeCodec = 'video/webm;codecs=\"vorbis,vp8\"';\n\n     \t\t\tif('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\n     \t\t\t\tvar mediaSource = new MediaSource();\n     \t\t\t\tvideo.src = URL.createObjectURL(mediaSource);\n     \t\t\t\tmediaSource.addEventListener('sourceopen', sourceOpen);\n     \t\t\t\t\n     \t\t\t} else {\n     \t\t\t\tconsole.error('Unsupported MIME type or codec: ', mimeCodec);\n     \t\t\t}\n\n     \t\t\tfunction sourceOpen() {\n     \t\t\t\tconsole.log(this); // open\n     \t\t\t\tvar mediaSource = this;\n     \t\t\t\tvar sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n     \t\t\t\tfetchAB(assetURL, function(buf) {\n     \t\t\t\t\tconsole.log(buf)\n     \t\t\t\t\tconsole.log(sourceBuffer);\n     \t\t\t\t\tsourceBuffer.addEventListener('updateend', function() {\n     \t\t\t\t\t\tconsole.log(mediaSource);\n     \t\t\t\t\t\tmediaSource.endOfStream();\n     \t\t\t\t\t\t\n     \t\t\t\t\t\tvideo.play();\n     \t\t\t\t\t\tconsole.log(mediaSource.readyState); // ended\n     \t\t\t\t\t});\n     \t\t\t\t\tsourceBuffer.appendBuffer(buf);\n     \t\t\t\t});\n     \t\t\t};\n     \t\t\tfunction fetchAB(url, cb) {\n     \t\t\t\tconsole.log(url);\n     \t\t\t\tvar xhr = new XMLHttpRequest;\n     \t\t\t\txhr.open('get', url);\n     \t\t\t\txhr.responseType = 'arraybuffer';\n     \t\t\t\txhr.onload = function() {\n     \t\t\t\t\tconsole.log(xhr.response);\n     \t\t\t\t\tcb(xhr.response);\n     \t\t\t\t};\n     \t\t\t\txhr.send();\n     \t\t\t};\n     \t\t</script>\n     \t</body>\n     </html>\n     ~~~\n","source":"_posts/note-taking-01.md","raw":"---\ntitle: note_taking_01\ndate: 2017-07-10 15:50:27\ntags: [blob]\ncategories: 随手笔记\n---\n\n### 关于blob类型的理解\n\n想下载一个视频时发现是个blob:src形式；不明白这个是个什么鬼，以下是搜索学习的总结\n\n1.   参考网址：https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html  。先来段代码熟悉下意思\n\n     ~~~javascript\n     var video=document.querySelector('video');\n     var mediaSource=new MdeiaSource;\n     video.Src=URL.createObjectURL(mediaSource);\n     mediaSource.addEventListener('sourceopen',sourceOpen);\n     function sourceOpen(){\n       var mediaSource=this;\n       var sourceBuffer = mediaSource.addSourceBuffer('video/mp4';codecs=\"avc1.42E01E,mp4a.40.2\");\n     sourceBuffer.addEventListener('updateend',function(){\n       mediaSource.endOfStream();\n       video.play();\n     })\n     sourceBuffer.appendBuffer(buf);// buf is the arraybuffer to store the video data\n     }\n     ~~~\n\n     代码解析：创建变量名为video的DOM对象，创建变量名为mediaSource的MediaSource对象。通过函数createObjectURL将video对象的src和mediaSource进行连接，然后通过注册事件event::sourceopen来触发当前连接之后的的回调处理；回调处理就是需要赋值视频数据的地方，调用MediaSourceBuffer::addSourceBuffer方法来构建一个存放视频数据的Buffer；在往buffer中存放数据结束后触发事件updateend。然后调用play函数通知浏览器播放视频\n\n2.   MediaSource :mediaSource是Media Source Extensions API表示媒体资源HTMLMediaElement对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。\n     参考网址：https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource\n\n     MediaSource属性：\n\n     1.   MediaSource.sourceBuffers:**只读** ，返回一个SourceBufferList对象，包含了SourceBuffer的列表object associated with this MediaSource.\n     2.   MediaSource.activeSourceBuffer:**只读** \n     3.   MediaSource.readyState:只读\n     4.   mediaSource.duration\n\n     方法：\n\n     1.   addSourceBuffer():该事件是在触发sourceopen监听时进行的，该动作会创建一个sourceBuffer对象用于数据流的播放处理。如果mediaSource对象无法触发该事件；则无法通过该扩展进行播放的。\n     2.   removeSourceBuffer():\n     3.   endOfStream()\n\n3.   MediaSource接口的使用：\n\n     参考网址：http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79\n\n     1.   判断是否mediaSource的扩展类，该语句决定了整个播放方式是否可以使用MediaSource接口控制播放器。\n\n          ~~~javascript\n          window.MediaSource = window.MediaSource || window.WebkitMediaSource;\n          ~~~\n\n     2.   isTypeSupporteed:判断是否支持要解码播放的视频文件编码和类型。\n\n          ~~~javascript\n          MediaSource.isTypeSupported('video/webm;codecs=\"vorbis,vp8\"');//是否支持webm\n          MediaSource.isTypeSupported('video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"')//是否支持MP4\n          MediaSource.isTypeSupported('video/mp2t;codes=\"avc1.42E01E,mp4a.40.2\"')//是否支持ts\n          ~~~\n\n     3.   addSourceBuffer\n\n          ~~~javascript\n          mediaSource.addSourceBuffer('video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"')\n          ~~~\n\n     4.   appendBuffer:sourceBuffer对象的方法，用于持续数据的添加播放\n\n          ~~~javascript\n          sourceBuffer.appendBuffer(Uint8array);//媒体二进制数据\n          ~~~\n\n     5.   buffered: 类型为TimeRanges，描述了添加进去的所有媒体数据的range信息。为一个数组，里边标示了持续或间断的时间信息列表\n\n          ~~~javascript\n          for(var i=0;i<buffered.length;i++){\n            start=buffered.start(i)//第i个range信息的开始时间\n            end=buffered.end(i);//第i个range信息的结束时间\n          }\n          ~~~\n\n          如果播放的媒体数据是连续的；则只有一个开始时间点和一个结束时间点。所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算\n\n          ~~~javascript\n          function play(){\n            if(!this.mediaSource){\n              this.mediaSource=new MediaSource();\n              var me=this;\n              this.mediaSource.addEventListener(\"sourceopen\",function(){\n                me.onMediaSourceOpen();\n              });\n              this.mediaSource.addEventListener(\"sourceended\",function(){\n                me.onMediaSourceEnded();\n              });\n              this.mediaSource.addEventListener('sourceclose',function(){\n                me.onMediaSourceClose();\n              });\n              this.mediaSource.addEventListener(\"error\",function(){\n                me.onUpdataError();\n              });\n              this.video=this.createNewVideo();\n              this.video.src=window.URL.createObjectURL(this.mediaSource);\n              this.video.play();\n            }\n            if(!this.sourceBuffer){\n              return ;\n            }\n            if(this.sourceBuffer.updating){\n              return;//上一块数据还在添加中\n            }\n            try{\n              this.sourceBuffer.appendBuffer(dataBytes);//添加数据\n            }catch(err){}\n          }\n            function createNewVideo(){\n              var newVideo=document.createElement(\"video\");\n              newVideo.id=\"player\";\n              newVideo.width=this.videoWidth;\n              newVideo.height=this.videoHeight;\n              return newVideo;\n            }\n            //事件侦听\n            onMediaSourceOpen:function(){\n              //DOMString可以通过转码获得\n              var typeNmae='video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"';\n              var issurpport=MediaSource.isTypeSupported(typeName);\n              this.mediaSource.duration=this.totalDuration;//设置视频总时长\n              this.sourceBuffer=this.mediaSource.addSourceBuffer(typeName);\n            }\n            onMediaSourceEnded:function(){\n              console.log(\"source ended\");\n            }\n            onMediaSourceClosed:function(){\n              console.log(\"cource close\");\n            }\n          }\n          ~~~\n\n4.   以下是自己做的一个demo；MP4格式的文件未成功；webm格式的成功了；但是不能跨越\n\n     ~~~\n     <!DOCTYPE html>\n     <html>\n\n     \t<head>\n     \t\t<meta charset=\"UTF-8\">\n     \t\t<title>blob</title>\n     \t</head>\n\n     \t<body>\n     \t\t<video id=\"video\" controls=\"controls\"></video>\n     \t\t<script type=\"text/javascript\">\n     \t\t\tvar video = document.querySelector('video');\n     \t\t\tvar assetURL = 'http://172.16.70.106:8020/Demo/Demo1/audio/test2.webm';\n     \t\t\t// Need to be specific for Blink regarding codecs\n     \t\t\t// ./mp4info frag_bunny.mp4 | grep Codec\n     \t\t\tvar mimeCodec = 'video/webm;codecs=\"vorbis,vp8\"';\n\n     \t\t\tif('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\n     \t\t\t\tvar mediaSource = new MediaSource();\n     \t\t\t\tvideo.src = URL.createObjectURL(mediaSource);\n     \t\t\t\tmediaSource.addEventListener('sourceopen', sourceOpen);\n     \t\t\t\t\n     \t\t\t} else {\n     \t\t\t\tconsole.error('Unsupported MIME type or codec: ', mimeCodec);\n     \t\t\t}\n\n     \t\t\tfunction sourceOpen() {\n     \t\t\t\tconsole.log(this); // open\n     \t\t\t\tvar mediaSource = this;\n     \t\t\t\tvar sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n     \t\t\t\tfetchAB(assetURL, function(buf) {\n     \t\t\t\t\tconsole.log(buf)\n     \t\t\t\t\tconsole.log(sourceBuffer);\n     \t\t\t\t\tsourceBuffer.addEventListener('updateend', function() {\n     \t\t\t\t\t\tconsole.log(mediaSource);\n     \t\t\t\t\t\tmediaSource.endOfStream();\n     \t\t\t\t\t\t\n     \t\t\t\t\t\tvideo.play();\n     \t\t\t\t\t\tconsole.log(mediaSource.readyState); // ended\n     \t\t\t\t\t});\n     \t\t\t\t\tsourceBuffer.appendBuffer(buf);\n     \t\t\t\t});\n     \t\t\t};\n     \t\t\tfunction fetchAB(url, cb) {\n     \t\t\t\tconsole.log(url);\n     \t\t\t\tvar xhr = new XMLHttpRequest;\n     \t\t\t\txhr.open('get', url);\n     \t\t\t\txhr.responseType = 'arraybuffer';\n     \t\t\t\txhr.onload = function() {\n     \t\t\t\t\tconsole.log(xhr.response);\n     \t\t\t\t\tcb(xhr.response);\n     \t\t\t\t};\n     \t\t\t\txhr.send();\n     \t\t\t};\n     \t\t</script>\n     \t</body>\n     </html>\n     ~~~\n","slug":"note-taking-01","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsewx0006ybf7z9byywaw","content":"<h3 id=\"关于blob类型的理解\"><a href=\"#关于blob类型的理解\" class=\"headerlink\" title=\"关于blob类型的理解\"></a>关于blob类型的理解</h3><p>想下载一个视频时发现是个blob:src形式；不明白这个是个什么鬼，以下是搜索学习的总结</p>\n<ol>\n<li><p>参考网址：<a href=\"https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html\" target=\"_blank\" rel=\"noopener\">https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html</a>  。先来段代码熟悉下意思</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video=<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'video'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mediaSource=<span class=\"keyword\">new</span> MdeiaSource;</span><br><span class=\"line\">video.Src=URL.createObjectURL(mediaSource);</span><br><span class=\"line\">mediaSource.addEventListener(<span class=\"string\">'sourceopen'</span>,sourceOpen);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sourceOpen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mediaSource=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sourceBuffer = mediaSource.addSourceBuffer(<span class=\"string\">'video/mp4'</span>;codecs=<span class=\"string\">\"avc1.42E01E,mp4a.40.2\"</span>);</span><br><span class=\"line\">sourceBuffer.addEventListener(<span class=\"string\">'updateend'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  mediaSource.endOfStream();</span><br><span class=\"line\">  video.play();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">sourceBuffer.appendBuffer(buf);<span class=\"comment\">// buf is the arraybuffer to store the video data</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码解析：创建变量名为video的DOM对象，创建变量名为mediaSource的MediaSource对象。通过函数createObjectURL将video对象的src和mediaSource进行连接，然后通过注册事件event::sourceopen来触发当前连接之后的的回调处理；回调处理就是需要赋值视频数据的地方，调用MediaSourceBuffer::addSourceBuffer方法来构建一个存放视频数据的Buffer；在往buffer中存放数据结束后触发事件updateend。然后调用play函数通知浏览器播放视频</p>\n</li>\n<li><p>MediaSource :mediaSource是Media Source Extensions API表示媒体资源HTMLMediaElement对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。<br>参考网址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource</a></p>\n<p>MediaSource属性：</p>\n<ol>\n<li>MediaSource.sourceBuffers:<strong>只读</strong> ，返回一个SourceBufferList对象，包含了SourceBuffer的列表object associated with this MediaSource.</li>\n<li>MediaSource.activeSourceBuffer:<strong>只读</strong> </li>\n<li>MediaSource.readyState:只读</li>\n<li>mediaSource.duration</li>\n</ol>\n<p>方法：</p>\n<ol>\n<li>addSourceBuffer():该事件是在触发sourceopen监听时进行的，该动作会创建一个sourceBuffer对象用于数据流的播放处理。如果mediaSource对象无法触发该事件；则无法通过该扩展进行播放的。</li>\n<li>removeSourceBuffer():</li>\n<li>endOfStream()</li>\n</ol>\n</li>\n<li><p>MediaSource接口的使用：</p>\n<p>参考网址：<a href=\"http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79\" target=\"_blank\" rel=\"noopener\">http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79</a></p>\n<ol>\n<li><p>判断是否mediaSource的扩展类，该语句决定了整个播放方式是否可以使用MediaSource接口控制播放器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.MediaSource = <span class=\"built_in\">window</span>.MediaSource || <span class=\"built_in\">window</span>.WebkitMediaSource;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>isTypeSupporteed:判断是否支持要解码播放的视频文件编码和类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/webm;codecs=\"vorbis,vp8\"'</span>);<span class=\"comment\">//是否支持webm</span></span><br><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>)<span class=\"comment\">//是否支持MP4</span></span><br><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/mp2t;codes=\"avc1.42E01E,mp4a.40.2\"'</span>)<span class=\"comment\">//是否支持ts</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>addSourceBuffer</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mediaSource.addSourceBuffer(<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>appendBuffer:sourceBuffer对象的方法，用于持续数据的添加播放</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sourceBuffer.appendBuffer(Uint8array);<span class=\"comment\">//媒体二进制数据</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>buffered: 类型为TimeRanges，描述了添加进去的所有媒体数据的range信息。为一个数组，里边标示了持续或间断的时间信息列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;buffered.length;i++)&#123;</span><br><span class=\"line\">  start=buffered.start(i)<span class=\"comment\">//第i个range信息的开始时间</span></span><br><span class=\"line\">  end=buffered.end(i);<span class=\"comment\">//第i个range信息的结束时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果播放的媒体数据是连续的；则只有一个开始时间点和一个结束时间点。所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">play</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.mediaSource)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource=<span class=\"keyword\">new</span> MediaSource();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> me=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"sourceopen\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceOpen();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"sourceended\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceEnded();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">'sourceclose'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceClose();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onUpdataError();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video=<span class=\"keyword\">this</span>.createNewVideo();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video.src=<span class=\"built_in\">window</span>.URL.createObjectURL(<span class=\"keyword\">this</span>.mediaSource);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video.play();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.sourceBuffer)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.sourceBuffer.updating)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;<span class=\"comment\">//上一块数据还在添加中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceBuffer.appendBuffer(dataBytes);<span class=\"comment\">//添加数据</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(err)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createNewVideo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newVideo=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"video\"</span>);</span><br><span class=\"line\">    newVideo.id=<span class=\"string\">\"player\"</span>;</span><br><span class=\"line\">    newVideo.width=<span class=\"keyword\">this</span>.videoWidth;</span><br><span class=\"line\">    newVideo.height=<span class=\"keyword\">this</span>.videoHeight;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//事件侦听</span></span><br><span class=\"line\">  onMediaSourceOpen:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOMString可以通过转码获得</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> typeNmae=<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> issurpport=MediaSource.isTypeSupported(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.duration=<span class=\"keyword\">this</span>.totalDuration;<span class=\"comment\">//设置视频总时长</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceBuffer=<span class=\"keyword\">this</span>.mediaSource.addSourceBuffer(typeName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMediaSourceEnded:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"source ended\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMediaSourceClosed:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"cource close\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>以下是自己做的一个demo；MP4格式的文件未成功；webm格式的成功了；但是不能跨越</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;blob&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br><span class=\"line\">\t\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t\t\tvar video = document.querySelector(&apos;video&apos;);</span><br><span class=\"line\">\t\t\tvar assetURL = &apos;http://172.16.70.106:8020/Demo/Demo1/audio/test2.webm&apos;;</span><br><span class=\"line\">\t\t\t// Need to be specific for Blink regarding codecs</span><br><span class=\"line\">\t\t\t// ./mp4info frag_bunny.mp4 | grep Codec</span><br><span class=\"line\">\t\t\tvar mimeCodec = &apos;video/webm;codecs=&quot;vorbis,vp8&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</span><br><span class=\"line\">\t\t\t\tvar mediaSource = new MediaSource();</span><br><span class=\"line\">\t\t\t\tvideo.src = URL.createObjectURL(mediaSource);</span><br><span class=\"line\">\t\t\t\tmediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tconsole.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfunction sourceOpen() &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(this); // open</span><br><span class=\"line\">\t\t\t\tvar mediaSource = this;</span><br><span class=\"line\">\t\t\t\tvar sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</span><br><span class=\"line\">\t\t\t\tfetchAB(assetURL, function(buf) &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.log(buf)</span><br><span class=\"line\">\t\t\t\t\tconsole.log(sourceBuffer);</span><br><span class=\"line\">\t\t\t\t\tsourceBuffer.addEventListener(&apos;updateend&apos;, function() &#123;</span><br><span class=\"line\">\t\t\t\t\t\tconsole.log(mediaSource);</span><br><span class=\"line\">\t\t\t\t\t\tmediaSource.endOfStream();</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\tvideo.play();</span><br><span class=\"line\">\t\t\t\t\t\tconsole.log(mediaSource.readyState); // ended</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsourceBuffer.appendBuffer(buf);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\tfunction fetchAB(url, cb) &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(url);</span><br><span class=\"line\">\t\t\t\tvar xhr = new XMLHttpRequest;</span><br><span class=\"line\">\t\t\t\txhr.open(&apos;get&apos;, url);</span><br><span class=\"line\">\t\t\t\txhr.responseType = &apos;arraybuffer&apos;;</span><br><span class=\"line\">\t\t\t\txhr.onload = function() &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.log(xhr.response);</span><br><span class=\"line\">\t\t\t\t\tcb(xhr.response);</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\txhr.send();</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&lt;/script&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于blob类型的理解\"><a href=\"#关于blob类型的理解\" class=\"headerlink\" title=\"关于blob类型的理解\"></a>关于blob类型的理解</h3><p>想下载一个视频时发现是个blob:src形式；不明白这个是个什么鬼，以下是搜索学习的总结</p>\n<ol>\n<li><p>参考网址：<a href=\"https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html\" target=\"_blank\" rel=\"noopener\">https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html</a>  。先来段代码熟悉下意思</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video=<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'video'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mediaSource=<span class=\"keyword\">new</span> MdeiaSource;</span><br><span class=\"line\">video.Src=URL.createObjectURL(mediaSource);</span><br><span class=\"line\">mediaSource.addEventListener(<span class=\"string\">'sourceopen'</span>,sourceOpen);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sourceOpen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mediaSource=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sourceBuffer = mediaSource.addSourceBuffer(<span class=\"string\">'video/mp4'</span>;codecs=<span class=\"string\">\"avc1.42E01E,mp4a.40.2\"</span>);</span><br><span class=\"line\">sourceBuffer.addEventListener(<span class=\"string\">'updateend'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  mediaSource.endOfStream();</span><br><span class=\"line\">  video.play();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">sourceBuffer.appendBuffer(buf);<span class=\"comment\">// buf is the arraybuffer to store the video data</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码解析：创建变量名为video的DOM对象，创建变量名为mediaSource的MediaSource对象。通过函数createObjectURL将video对象的src和mediaSource进行连接，然后通过注册事件event::sourceopen来触发当前连接之后的的回调处理；回调处理就是需要赋值视频数据的地方，调用MediaSourceBuffer::addSourceBuffer方法来构建一个存放视频数据的Buffer；在往buffer中存放数据结束后触发事件updateend。然后调用play函数通知浏览器播放视频</p>\n</li>\n<li><p>MediaSource :mediaSource是Media Source Extensions API表示媒体资源HTMLMediaElement对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。<br>参考网址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource</a></p>\n<p>MediaSource属性：</p>\n<ol>\n<li>MediaSource.sourceBuffers:<strong>只读</strong> ，返回一个SourceBufferList对象，包含了SourceBuffer的列表object associated with this MediaSource.</li>\n<li>MediaSource.activeSourceBuffer:<strong>只读</strong> </li>\n<li>MediaSource.readyState:只读</li>\n<li>mediaSource.duration</li>\n</ol>\n<p>方法：</p>\n<ol>\n<li>addSourceBuffer():该事件是在触发sourceopen监听时进行的，该动作会创建一个sourceBuffer对象用于数据流的播放处理。如果mediaSource对象无法触发该事件；则无法通过该扩展进行播放的。</li>\n<li>removeSourceBuffer():</li>\n<li>endOfStream()</li>\n</ol>\n</li>\n<li><p>MediaSource接口的使用：</p>\n<p>参考网址：<a href=\"http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79\" target=\"_blank\" rel=\"noopener\">http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79</a></p>\n<ol>\n<li><p>判断是否mediaSource的扩展类，该语句决定了整个播放方式是否可以使用MediaSource接口控制播放器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.MediaSource = <span class=\"built_in\">window</span>.MediaSource || <span class=\"built_in\">window</span>.WebkitMediaSource;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>isTypeSupporteed:判断是否支持要解码播放的视频文件编码和类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/webm;codecs=\"vorbis,vp8\"'</span>);<span class=\"comment\">//是否支持webm</span></span><br><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>)<span class=\"comment\">//是否支持MP4</span></span><br><span class=\"line\">MediaSource.isTypeSupported(<span class=\"string\">'video/mp2t;codes=\"avc1.42E01E,mp4a.40.2\"'</span>)<span class=\"comment\">//是否支持ts</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>addSourceBuffer</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mediaSource.addSourceBuffer(<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>appendBuffer:sourceBuffer对象的方法，用于持续数据的添加播放</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sourceBuffer.appendBuffer(Uint8array);<span class=\"comment\">//媒体二进制数据</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>buffered: 类型为TimeRanges，描述了添加进去的所有媒体数据的range信息。为一个数组，里边标示了持续或间断的时间信息列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;buffered.length;i++)&#123;</span><br><span class=\"line\">  start=buffered.start(i)<span class=\"comment\">//第i个range信息的开始时间</span></span><br><span class=\"line\">  end=buffered.end(i);<span class=\"comment\">//第i个range信息的结束时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果播放的媒体数据是连续的；则只有一个开始时间点和一个结束时间点。所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">play</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.mediaSource)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource=<span class=\"keyword\">new</span> MediaSource();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> me=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"sourceopen\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceOpen();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"sourceended\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceEnded();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">'sourceclose'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onMediaSourceClose();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.addEventListener(<span class=\"string\">\"error\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      me.onUpdataError();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video=<span class=\"keyword\">this</span>.createNewVideo();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video.src=<span class=\"built_in\">window</span>.URL.createObjectURL(<span class=\"keyword\">this</span>.mediaSource);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.video.play();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.sourceBuffer)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.sourceBuffer.updating)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;<span class=\"comment\">//上一块数据还在添加中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceBuffer.appendBuffer(dataBytes);<span class=\"comment\">//添加数据</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(err)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createNewVideo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newVideo=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"video\"</span>);</span><br><span class=\"line\">    newVideo.id=<span class=\"string\">\"player\"</span>;</span><br><span class=\"line\">    newVideo.width=<span class=\"keyword\">this</span>.videoWidth;</span><br><span class=\"line\">    newVideo.height=<span class=\"keyword\">this</span>.videoHeight;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//事件侦听</span></span><br><span class=\"line\">  onMediaSourceOpen:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOMString可以通过转码获得</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> typeNmae=<span class=\"string\">'video/mp4;codecs=\"avc1.42E01E,mp4a.40.2\"'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> issurpport=MediaSource.isTypeSupported(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mediaSource.duration=<span class=\"keyword\">this</span>.totalDuration;<span class=\"comment\">//设置视频总时长</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceBuffer=<span class=\"keyword\">this</span>.mediaSource.addSourceBuffer(typeName);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMediaSourceEnded:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"source ended\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMediaSourceClosed:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"cource close\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>以下是自己做的一个demo；MP4格式的文件未成功；webm格式的成功了；但是不能跨越</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;blob&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br><span class=\"line\">\t\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t\t\tvar video = document.querySelector(&apos;video&apos;);</span><br><span class=\"line\">\t\t\tvar assetURL = &apos;http://172.16.70.106:8020/Demo/Demo1/audio/test2.webm&apos;;</span><br><span class=\"line\">\t\t\t// Need to be specific for Blink regarding codecs</span><br><span class=\"line\">\t\t\t// ./mp4info frag_bunny.mp4 | grep Codec</span><br><span class=\"line\">\t\t\tvar mimeCodec = &apos;video/webm;codecs=&quot;vorbis,vp8&quot;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tif(&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</span><br><span class=\"line\">\t\t\t\tvar mediaSource = new MediaSource();</span><br><span class=\"line\">\t\t\t\tvideo.src = URL.createObjectURL(mediaSource);</span><br><span class=\"line\">\t\t\t\tmediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tconsole.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfunction sourceOpen() &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(this); // open</span><br><span class=\"line\">\t\t\t\tvar mediaSource = this;</span><br><span class=\"line\">\t\t\t\tvar sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</span><br><span class=\"line\">\t\t\t\tfetchAB(assetURL, function(buf) &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.log(buf)</span><br><span class=\"line\">\t\t\t\t\tconsole.log(sourceBuffer);</span><br><span class=\"line\">\t\t\t\t\tsourceBuffer.addEventListener(&apos;updateend&apos;, function() &#123;</span><br><span class=\"line\">\t\t\t\t\t\tconsole.log(mediaSource);</span><br><span class=\"line\">\t\t\t\t\t\tmediaSource.endOfStream();</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\tvideo.play();</span><br><span class=\"line\">\t\t\t\t\t\tconsole.log(mediaSource.readyState); // ended</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\tsourceBuffer.appendBuffer(buf);</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t\tfunction fetchAB(url, cb) &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(url);</span><br><span class=\"line\">\t\t\t\tvar xhr = new XMLHttpRequest;</span><br><span class=\"line\">\t\t\t\txhr.open(&apos;get&apos;, url);</span><br><span class=\"line\">\t\t\t\txhr.responseType = &apos;arraybuffer&apos;;</span><br><span class=\"line\">\t\t\t\txhr.onload = function() &#123;</span><br><span class=\"line\">\t\t\t\t\tconsole.log(xhr.response);</span><br><span class=\"line\">\t\t\t\t\tcb(xhr.response);</span><br><span class=\"line\">\t\t\t\t&#125;;</span><br><span class=\"line\">\t\t\t\txhr.send();</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\">\t\t&lt;/script&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"referenceType_1","date":"2017-07-06T08:38:37.000Z","_content":"\n[TOC]\n\n## 引用类型\n\n在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。对象是某个特定引用功能的实例\n\n### object类型\n\n创建object实例的方式有两种：\n\n*    使用new操作符后跟Object构造函数\n\n*    ~~~javascript\n     var person=new Object();\n     person.name=\"haohualiangshi\";\n     person.age=29;\n     ~~~\n\n*    使用对象字面量的表示方法\n\n*    ~~~javascript\n     var person={\n       name:\"haohualiangshi\",\n       age:25\n     }\n     ~~~\n\n*    对象字面量是向函数传递大量可选参数的的首选方式\n\n### Array类型\n\njs中数组的每一项都可以保存不同类型的数据。创建数组的基本方式有两种：使用Array构造函数，使用数组字面量表示法。\n\n数组的存储方式有栈方法和队列方法：\n\n*    栈是一种LIFO（后进先出）的数据结构，栈的操作方法：push()和pop()方法，push方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。而pop方法则从数组末尾移除最后一项；并返回移除的项。\n*    队列方法的访问规则是FIFO（先进先出）；队列是在列表的末端添加；在列表的前端移除项；其操作是用push方法在数组的末尾添加数组项；用shift方法移除数组的第一项并返回该项；另外数组还提供了unshift方法；其作用与shift方法相反；与push类似；在数组的前端添加任意个数组项并返回新的数组长度，使用shift和unshift方法可以从相反的方向模拟队列.\n\n数组中定义好的的重排序方法：\n\n*    reverse()  :翻转数组项的顺序\n*    sort()  : 默认情况下sort方法是按升序排序的；注意；sort方法比较的是字符串：sort方法会调用每个数组项的toString；然后进行对比。该函数可以通过传递两个参数进行灵活的排序操作：如果第一个参数位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个参数之后，则返回正数。\n\n操作方法：\n\n*    concat()方法可以基于当前数组中的所有项创建一个新的数组，他的参数可以传递一个或者多个\n\n     ~~~javascript\n     var colors=[\"red\",\"green\",\"#888\"];\n     colors.concat(\"#999\",[\"#333\",\"#999\"]);//[\"red\", \"green\", \"#888\", \"#999\", \"#333\", \"#999\"]\n     ~~~\n\n*    slice()方法：它能够基于当前数组的一个或者多个项创建一个新数组。两个参数表示起始位置和结束位置；第二个参数可选\n\n*    splice()方法：可以完成删除、插入和替换：该方法始终返回一个数组，该数组包含从原始数组中删除的项。无删除项则返回空数组。\n\n     *    删除：需要指定两个参数；要删除的第一项的位置和要删除的项数\n\n          ~~~javascript\n          var colors=[\"red\",\"green\",\"yellow\"];\n          colors.splice(0,2);//[\"red\", \"green\"]\n          ~~~\n\n     *    插入：需要提供三个参数，起始位置、删除的项数和插入的任意项数\n\n          ~~~javascript\n          var colors=[\"red\",\"green\",\"yellow\"];\n          colors.splice(1,0,\"#999\",\"#888\");\n          console.log(colors);\n          ~~~\n\n     *    替换：可以向指定的位置插入任意数量的项；并指定三个参数：起始位置、要删除的项数和要插入的任意数量的项\n\n位置方法：两个位置方法：indexof()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引；其中indexOf()从数组的开头向后查找；lastIndexOf()从数组的末尾向前查找；没有找到则返回-1。\n\n迭代方法：es5定义了**5**种迭代方法。每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象--影响this的值；传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身；以下是五个迭代方法\n\n*    every():对数组中的每一项运行给定的函数，如果该函数每一项都返回true；则返回true\n\n*    filter():对数组中的每一项运行给定函数；返回该函数会返回true的项组成的数组\n\n*    forEach():对数组中的每一项运行给定函数，这个方法没有返回值\n\n*    map()：对数组中的每一项运行给定函数；返回每次函数调用的结果返回的数组\n\n*    some(): 对数组中的每一项运行给定函数；如果该函数对数组中的任意一项返回true则返回true\n\n     ~~~javascript\n     var numArr=[1,2,3,4,5,4,3,2,1];\n     var everyResult=numArr.every(function(item,index,array){\n       return (item>2);\n     });\n     console.log(everyResult);\n     var someResult=numArr.some(function(item,index,array){\n       return (item>2);\n     });\n     console.log(someResult);\n\n     var filterResult=numArr.filter(function(item,index,array){\n       return (item>2);\n     });\n     console.log(filterResult);\n     var mapResult=numArr.map(function(item,index,array){\n       return (item >2);\n     })\n     console.log(mapResult);\n     //forEach没有返回值；能够对数组的每一项执行操作\n     numArr.forEach(function(item,index,array){\n       console.log(item+1);\n     })\n     ~~~\n\nes5新增了两个归并方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项；然后构建一个最终返回的值。reduce()方法从数组的第一项开始；逐个便利到最后；而reduceRight()则从数组的最后一项开始；逐个便利到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和可做为归并基础的初始值（可选）\n\n~~~javascript\nvar reduceArr=[1,2,3,4,5];\nreduceArr.reduce(function(prev,cur,index,array){\n  //四个参数分别是前一个结果值、当前值、项的索引和数组对象\n  console.log(cur);\n  return prev+cur;\n});\nreduceArr.reduceRight(function(prev,cur,index,array){\n  console.log(cur);\n  return prev+cur;\n})\n~~~\n\n### Date类型\n\n通过new Date()来获取当前的时间的字符串；如果要获取特定日期；需要传入表示该日期的毫秒数‘为例；为了简化过程；js提供了两个方法Date.parse()和Date.UTC();\n\nDate.parse()方法接收一个表示日期的字符串参数；然后尝试根据字符串返回对应的毫秒数；解析不成功则返回NaN\n\nES5中添加了Date.now()方法；返回调用该方法时日期和时间的毫秒数；日期做比较时调用valueof方法；日期比较的是毫秒数\n\n### Function类型\n\n函数其实是对象；每个函数都是Function类型的实例，因此函数名实际上也是指向函数对象的指针。函数声明和函数表达式是有区别的：函数声明在解析时会提升；函数表达式则不会；必须先定义后使用\n\n在函数内部有两个特殊的对象：arguments和this\n\n*    arguments拥有一个callee的属性，该属性是个指针，指向拥有这个arguments对象的函数，在非严格模式下使用，例如函数阶乘\n\n     ~~~javascript\n     function factorial(num){\n       if(num<=1){\n         return 1\n       }else{\n         return num*arguments.callee(num-1);\n       }\n     }\n     factorial(5);//120\n     ~~~\n\n*    函数的另外一个对象是this：this引用的是函数据以执行的环境对象（在网页的全局作用域中调用函数时this对象引用的就是不window对象\n\n*    在非严格模式下es5规范化了另外一个函数对象的属性：caller属性保存着当前函数的函数的引用；如果在全局作用域中调用当前函数；他的值为null;在严格模式下使用caller或者arguments.callee.caller都会造成错误\n\n     ~~~javascript\n     \"use strict\"\n     function outer(){\n       inner();\n       console.log(outer.caller);\n     }\n     function inner(){\n       alert(arguments.callee.caller);//指向函数outer\n     }\n     outer();\n     ~~~\n\n*    函数还具有length和prototype属性：length属性表示形参的个数，prototype属性是保存他们所有实例方法的真正所在，该属性不可枚举\n\n*    每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途是在特定的作用域中调用函数；并能扩展函数的作用域\n\n     ~~~javascript\n     window.color=\"red\";\n     var o={color:\"blue\"};\n     function sayColor(){\n       console.log(this.color);\n     }\n     sayColor.call(this);\n     sayColor.call(o);\n     sayColor.call(window);\n     ~~~\n\n*    es5还定义了bind()方法;该方法会创建一个函数的实例；其this值会被绑定到传给bind()函数的值\n\n     ~~~javascript\n     var color=\"red\";\n     var o={color:\"blue\"};\n     function sayColor(){\n       console.log(this.color);\n     }\n     var objectColor=sayColor.bind(o);\n\n     ~~~\n\n### 基本包装类型\n\n为了便于操作基本类型的值；js引入了三个特殊的引用类型；Boolean、Number和String。\n\nNumber类型提供了一些用于将数值格式化为字符串的方法：\n\n*    toFixed()方法会按照指定的小数位返回数值的字符串表示,该方法具有自动舍入的特性\n\n~~~javascript\nvar num=10.005;\nconsole.log(num.toFixed(2));//10.01\n~~~\n\n*    toExponential()方法；该方法返回指数表示法；表示数值的字符串形式;接收一个参数用来表示小数位\n\n     ~~~javascript\n     var num=19;\n     console.log(num.toExponential(2))\n     ~~~\n\n*    toPrecision()可以根据参数的不同用恰当的字符串来表示数值\n\n     ~~~javascript\n     var num=99;\n     console.log(num.toPrecision(1));\n     console.log(num.toPrecision(2));\n     console.log(num.toPrecision(3));\n     ~~~\n\n### String类型\n\nString对象的属性和方法也可以在所有的字符串中访问，string类型的每个实例都有length属性，表示字符串包含多少个字符\n\n*    charAt()和charCodeAt();这两个方法都接收一个表示字符索引位置的参数；charAt()返回给定位置的那个字符。charCodeAt()返回的是索引位置对应的编码\n\n     ~~~javascript\n     var test=\"hello\";\n     console.log(test.charAt(2));//\"l\"\n     console.log(test.charCodeAt(2))//108\n     ~~~\n\n*    concat()方法的作用同数组的concat方法相同，用于将一个或者多个字符串拼接起来，返回得到的新字符串；\n\n*    基于子字符串创建新字符串的三个方法：slice()、substr()和substring();这三个方法都返回被操作字符串的子字符串，接收一个或者两个参数。第二个参数的区别是slice()和substring()指定的是字符串最后一个字符后边的位置(包头不包尾)。而substring()的第二个参数指定的则是返回字符的个数;如果不传第二个参数则默认截取到最后。这三个方法都对原始字符串无影响\n\n     这三个方法都是可以传入负值的；对负值的解析也不相同：slice()方法会将传入的负值与长度相加，substr()会将负值的第一个参数与长度相加；第二个参数转为0，substring会将所有的负值转为0\n\n     ~~~javascript\n     var test=\"this is a test string\";\n     console.log(test.substring(1,3));//hi\n     console.log(test.slice(1,3));//hi\n     console.log(test.substr(1,3));//his\n     ~~~\n\n*    indexOf()和lastIndexOf();从一个字符串中搜寻给定的字符串，然后返回给定字符串的位置；没找到则返回-1\n\n*    trim()方法；这个方法创建一个字符串的副本，删除前置以及后置的所有空格并返回结果\n\n*    字符串的大小写转换：js中有四个涉及大小写转换的方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocalUpperCase()\n\n*    字符串的模式匹配方法\n\n     *    match()方法，在字符串上调用这个方法本质上与调用RegExp的exec()方法相同，match方法只接收一个参数，要么是个正则表达式，要么是个RegExp对象\n\n          ~~~javascript\n          var text=\"cat,bat,sat,fat\";\n          var pattern=/.at/;\n          //与 pattern.exec(text)相同\n          var matches=text.match(pattern);\n          console.log(matches);//[\"cat\", index: 0, input: \"cat,bat,sat,fat\"]\n          ~~~\n\n     *    search():该方法的唯一参数与match()相同；返回字符串中第一个匹配项的索引；未找到则返回-1\n\n     *    replace()方法：该方法接收两个参数，第一个参数可以是正则表达式或者一个字符串，第二个参数可以是个字符串或者函数\n\n          ~~~javascript\n          var text=\"cat,bat,sat,fat\";\n          var result=text.replace(\"at\",\"ond\");\n          console.log(result);//cond,bat,sat,fat\n          //替换所有需要使用正则的全局标志\n          result=text.replace(/at/g,\"ond\");\n          console.log(result);//cond,bond,sond,fond\n          ~~~\n\n*    split()方法：这个方法可以基于指定的分割符将一个字符串分割成多个字符串，并将结果放在数组中；该方法可以接收第二个参数用于截取数组的长度。\n\n*    localeCompare()方法：这个方法比较两个字符串，并返回下列值中的一个\n\n     *    如果字符串在字母表中应该排在字符串参数之前，则返回一个负数\n     *    如果字符串等于字符串参数，则返回0\n     *    如果字符串在字母表中的位置排在字符串参数之后，返回一个正数\n\n     ~~~javascript\n     var stringValue=\"yellow\";\n     console.log(stringValue.localeCompare(\"brick\"));//1\n     console.log(stringValue.localeCompare(\"yellow\"));//0\n     console.log(stringValue.localeCompare(\"zoo\"));//-1\n     ~~~\n\n     ​","source":"_posts/referenceType-1.md","raw":"---\ntitle: referenceType_1\ndate: 2017-07-06 16:38:37\ntags: [js,引用类型]\ncategories: js教程总结\n---\n\n[TOC]\n\n## 引用类型\n\n在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。对象是某个特定引用功能的实例\n\n### object类型\n\n创建object实例的方式有两种：\n\n*    使用new操作符后跟Object构造函数\n\n*    ~~~javascript\n     var person=new Object();\n     person.name=\"haohualiangshi\";\n     person.age=29;\n     ~~~\n\n*    使用对象字面量的表示方法\n\n*    ~~~javascript\n     var person={\n       name:\"haohualiangshi\",\n       age:25\n     }\n     ~~~\n\n*    对象字面量是向函数传递大量可选参数的的首选方式\n\n### Array类型\n\njs中数组的每一项都可以保存不同类型的数据。创建数组的基本方式有两种：使用Array构造函数，使用数组字面量表示法。\n\n数组的存储方式有栈方法和队列方法：\n\n*    栈是一种LIFO（后进先出）的数据结构，栈的操作方法：push()和pop()方法，push方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。而pop方法则从数组末尾移除最后一项；并返回移除的项。\n*    队列方法的访问规则是FIFO（先进先出）；队列是在列表的末端添加；在列表的前端移除项；其操作是用push方法在数组的末尾添加数组项；用shift方法移除数组的第一项并返回该项；另外数组还提供了unshift方法；其作用与shift方法相反；与push类似；在数组的前端添加任意个数组项并返回新的数组长度，使用shift和unshift方法可以从相反的方向模拟队列.\n\n数组中定义好的的重排序方法：\n\n*    reverse()  :翻转数组项的顺序\n*    sort()  : 默认情况下sort方法是按升序排序的；注意；sort方法比较的是字符串：sort方法会调用每个数组项的toString；然后进行对比。该函数可以通过传递两个参数进行灵活的排序操作：如果第一个参数位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个参数之后，则返回正数。\n\n操作方法：\n\n*    concat()方法可以基于当前数组中的所有项创建一个新的数组，他的参数可以传递一个或者多个\n\n     ~~~javascript\n     var colors=[\"red\",\"green\",\"#888\"];\n     colors.concat(\"#999\",[\"#333\",\"#999\"]);//[\"red\", \"green\", \"#888\", \"#999\", \"#333\", \"#999\"]\n     ~~~\n\n*    slice()方法：它能够基于当前数组的一个或者多个项创建一个新数组。两个参数表示起始位置和结束位置；第二个参数可选\n\n*    splice()方法：可以完成删除、插入和替换：该方法始终返回一个数组，该数组包含从原始数组中删除的项。无删除项则返回空数组。\n\n     *    删除：需要指定两个参数；要删除的第一项的位置和要删除的项数\n\n          ~~~javascript\n          var colors=[\"red\",\"green\",\"yellow\"];\n          colors.splice(0,2);//[\"red\", \"green\"]\n          ~~~\n\n     *    插入：需要提供三个参数，起始位置、删除的项数和插入的任意项数\n\n          ~~~javascript\n          var colors=[\"red\",\"green\",\"yellow\"];\n          colors.splice(1,0,\"#999\",\"#888\");\n          console.log(colors);\n          ~~~\n\n     *    替换：可以向指定的位置插入任意数量的项；并指定三个参数：起始位置、要删除的项数和要插入的任意数量的项\n\n位置方法：两个位置方法：indexof()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引；其中indexOf()从数组的开头向后查找；lastIndexOf()从数组的末尾向前查找；没有找到则返回-1。\n\n迭代方法：es5定义了**5**种迭代方法。每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象--影响this的值；传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身；以下是五个迭代方法\n\n*    every():对数组中的每一项运行给定的函数，如果该函数每一项都返回true；则返回true\n\n*    filter():对数组中的每一项运行给定函数；返回该函数会返回true的项组成的数组\n\n*    forEach():对数组中的每一项运行给定函数，这个方法没有返回值\n\n*    map()：对数组中的每一项运行给定函数；返回每次函数调用的结果返回的数组\n\n*    some(): 对数组中的每一项运行给定函数；如果该函数对数组中的任意一项返回true则返回true\n\n     ~~~javascript\n     var numArr=[1,2,3,4,5,4,3,2,1];\n     var everyResult=numArr.every(function(item,index,array){\n       return (item>2);\n     });\n     console.log(everyResult);\n     var someResult=numArr.some(function(item,index,array){\n       return (item>2);\n     });\n     console.log(someResult);\n\n     var filterResult=numArr.filter(function(item,index,array){\n       return (item>2);\n     });\n     console.log(filterResult);\n     var mapResult=numArr.map(function(item,index,array){\n       return (item >2);\n     })\n     console.log(mapResult);\n     //forEach没有返回值；能够对数组的每一项执行操作\n     numArr.forEach(function(item,index,array){\n       console.log(item+1);\n     })\n     ~~~\n\nes5新增了两个归并方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项；然后构建一个最终返回的值。reduce()方法从数组的第一项开始；逐个便利到最后；而reduceRight()则从数组的最后一项开始；逐个便利到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和可做为归并基础的初始值（可选）\n\n~~~javascript\nvar reduceArr=[1,2,3,4,5];\nreduceArr.reduce(function(prev,cur,index,array){\n  //四个参数分别是前一个结果值、当前值、项的索引和数组对象\n  console.log(cur);\n  return prev+cur;\n});\nreduceArr.reduceRight(function(prev,cur,index,array){\n  console.log(cur);\n  return prev+cur;\n})\n~~~\n\n### Date类型\n\n通过new Date()来获取当前的时间的字符串；如果要获取特定日期；需要传入表示该日期的毫秒数‘为例；为了简化过程；js提供了两个方法Date.parse()和Date.UTC();\n\nDate.parse()方法接收一个表示日期的字符串参数；然后尝试根据字符串返回对应的毫秒数；解析不成功则返回NaN\n\nES5中添加了Date.now()方法；返回调用该方法时日期和时间的毫秒数；日期做比较时调用valueof方法；日期比较的是毫秒数\n\n### Function类型\n\n函数其实是对象；每个函数都是Function类型的实例，因此函数名实际上也是指向函数对象的指针。函数声明和函数表达式是有区别的：函数声明在解析时会提升；函数表达式则不会；必须先定义后使用\n\n在函数内部有两个特殊的对象：arguments和this\n\n*    arguments拥有一个callee的属性，该属性是个指针，指向拥有这个arguments对象的函数，在非严格模式下使用，例如函数阶乘\n\n     ~~~javascript\n     function factorial(num){\n       if(num<=1){\n         return 1\n       }else{\n         return num*arguments.callee(num-1);\n       }\n     }\n     factorial(5);//120\n     ~~~\n\n*    函数的另外一个对象是this：this引用的是函数据以执行的环境对象（在网页的全局作用域中调用函数时this对象引用的就是不window对象\n\n*    在非严格模式下es5规范化了另外一个函数对象的属性：caller属性保存着当前函数的函数的引用；如果在全局作用域中调用当前函数；他的值为null;在严格模式下使用caller或者arguments.callee.caller都会造成错误\n\n     ~~~javascript\n     \"use strict\"\n     function outer(){\n       inner();\n       console.log(outer.caller);\n     }\n     function inner(){\n       alert(arguments.callee.caller);//指向函数outer\n     }\n     outer();\n     ~~~\n\n*    函数还具有length和prototype属性：length属性表示形参的个数，prototype属性是保存他们所有实例方法的真正所在，该属性不可枚举\n\n*    每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途是在特定的作用域中调用函数；并能扩展函数的作用域\n\n     ~~~javascript\n     window.color=\"red\";\n     var o={color:\"blue\"};\n     function sayColor(){\n       console.log(this.color);\n     }\n     sayColor.call(this);\n     sayColor.call(o);\n     sayColor.call(window);\n     ~~~\n\n*    es5还定义了bind()方法;该方法会创建一个函数的实例；其this值会被绑定到传给bind()函数的值\n\n     ~~~javascript\n     var color=\"red\";\n     var o={color:\"blue\"};\n     function sayColor(){\n       console.log(this.color);\n     }\n     var objectColor=sayColor.bind(o);\n\n     ~~~\n\n### 基本包装类型\n\n为了便于操作基本类型的值；js引入了三个特殊的引用类型；Boolean、Number和String。\n\nNumber类型提供了一些用于将数值格式化为字符串的方法：\n\n*    toFixed()方法会按照指定的小数位返回数值的字符串表示,该方法具有自动舍入的特性\n\n~~~javascript\nvar num=10.005;\nconsole.log(num.toFixed(2));//10.01\n~~~\n\n*    toExponential()方法；该方法返回指数表示法；表示数值的字符串形式;接收一个参数用来表示小数位\n\n     ~~~javascript\n     var num=19;\n     console.log(num.toExponential(2))\n     ~~~\n\n*    toPrecision()可以根据参数的不同用恰当的字符串来表示数值\n\n     ~~~javascript\n     var num=99;\n     console.log(num.toPrecision(1));\n     console.log(num.toPrecision(2));\n     console.log(num.toPrecision(3));\n     ~~~\n\n### String类型\n\nString对象的属性和方法也可以在所有的字符串中访问，string类型的每个实例都有length属性，表示字符串包含多少个字符\n\n*    charAt()和charCodeAt();这两个方法都接收一个表示字符索引位置的参数；charAt()返回给定位置的那个字符。charCodeAt()返回的是索引位置对应的编码\n\n     ~~~javascript\n     var test=\"hello\";\n     console.log(test.charAt(2));//\"l\"\n     console.log(test.charCodeAt(2))//108\n     ~~~\n\n*    concat()方法的作用同数组的concat方法相同，用于将一个或者多个字符串拼接起来，返回得到的新字符串；\n\n*    基于子字符串创建新字符串的三个方法：slice()、substr()和substring();这三个方法都返回被操作字符串的子字符串，接收一个或者两个参数。第二个参数的区别是slice()和substring()指定的是字符串最后一个字符后边的位置(包头不包尾)。而substring()的第二个参数指定的则是返回字符的个数;如果不传第二个参数则默认截取到最后。这三个方法都对原始字符串无影响\n\n     这三个方法都是可以传入负值的；对负值的解析也不相同：slice()方法会将传入的负值与长度相加，substr()会将负值的第一个参数与长度相加；第二个参数转为0，substring会将所有的负值转为0\n\n     ~~~javascript\n     var test=\"this is a test string\";\n     console.log(test.substring(1,3));//hi\n     console.log(test.slice(1,3));//hi\n     console.log(test.substr(1,3));//his\n     ~~~\n\n*    indexOf()和lastIndexOf();从一个字符串中搜寻给定的字符串，然后返回给定字符串的位置；没找到则返回-1\n\n*    trim()方法；这个方法创建一个字符串的副本，删除前置以及后置的所有空格并返回结果\n\n*    字符串的大小写转换：js中有四个涉及大小写转换的方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocalUpperCase()\n\n*    字符串的模式匹配方法\n\n     *    match()方法，在字符串上调用这个方法本质上与调用RegExp的exec()方法相同，match方法只接收一个参数，要么是个正则表达式，要么是个RegExp对象\n\n          ~~~javascript\n          var text=\"cat,bat,sat,fat\";\n          var pattern=/.at/;\n          //与 pattern.exec(text)相同\n          var matches=text.match(pattern);\n          console.log(matches);//[\"cat\", index: 0, input: \"cat,bat,sat,fat\"]\n          ~~~\n\n     *    search():该方法的唯一参数与match()相同；返回字符串中第一个匹配项的索引；未找到则返回-1\n\n     *    replace()方法：该方法接收两个参数，第一个参数可以是正则表达式或者一个字符串，第二个参数可以是个字符串或者函数\n\n          ~~~javascript\n          var text=\"cat,bat,sat,fat\";\n          var result=text.replace(\"at\",\"ond\");\n          console.log(result);//cond,bat,sat,fat\n          //替换所有需要使用正则的全局标志\n          result=text.replace(/at/g,\"ond\");\n          console.log(result);//cond,bond,sond,fond\n          ~~~\n\n*    split()方法：这个方法可以基于指定的分割符将一个字符串分割成多个字符串，并将结果放在数组中；该方法可以接收第二个参数用于截取数组的长度。\n\n*    localeCompare()方法：这个方法比较两个字符串，并返回下列值中的一个\n\n     *    如果字符串在字母表中应该排在字符串参数之前，则返回一个负数\n     *    如果字符串等于字符串参数，则返回0\n     *    如果字符串在字母表中的位置排在字符串参数之后，返回一个正数\n\n     ~~~javascript\n     var stringValue=\"yellow\";\n     console.log(stringValue.localeCompare(\"brick\"));//1\n     console.log(stringValue.localeCompare(\"yellow\"));//0\n     console.log(stringValue.localeCompare(\"zoo\"));//-1\n     ~~~\n\n     ​","slug":"referenceType-1","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsex00009ybf76bsmr10s","content":"<p>[TOC]</p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。对象是某个特定引用功能的实例</p>\n<h3 id=\"object类型\"><a href=\"#object类型\" class=\"headerlink\" title=\"object类型\"></a>object类型</h3><p>创建object实例的方式有两种：</p>\n<ul>\n<li><p>使用new操作符后跟Object构造函数</p>\n</li>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person=<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name=<span class=\"string\">\"haohualiangshi\"</span>;</span><br><span class=\"line\">person.age=<span class=\"number\">29</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用对象字面量的表示方法</p>\n</li>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">\"haohualiangshi\"</span>,</span><br><span class=\"line\">  age:<span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象字面量是向函数传递大量可选参数的的首选方式</p>\n</li>\n</ul>\n<h3 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h3><p>js中数组的每一项都可以保存不同类型的数据。创建数组的基本方式有两种：使用Array构造函数，使用数组字面量表示法。</p>\n<p>数组的存储方式有栈方法和队列方法：</p>\n<ul>\n<li>栈是一种LIFO（后进先出）的数据结构，栈的操作方法：push()和pop()方法，push方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。而pop方法则从数组末尾移除最后一项；并返回移除的项。</li>\n<li>队列方法的访问规则是FIFO（先进先出）；队列是在列表的末端添加；在列表的前端移除项；其操作是用push方法在数组的末尾添加数组项；用shift方法移除数组的第一项并返回该项；另外数组还提供了unshift方法；其作用与shift方法相反；与push类似；在数组的前端添加任意个数组项并返回新的数组长度，使用shift和unshift方法可以从相反的方向模拟队列.</li>\n</ul>\n<p>数组中定义好的的重排序方法：</p>\n<ul>\n<li>reverse()  :翻转数组项的顺序</li>\n<li>sort()  : 默认情况下sort方法是按升序排序的；注意；sort方法比较的是字符串：sort方法会调用每个数组项的toString；然后进行对比。该函数可以通过传递两个参数进行灵活的排序操作：如果第一个参数位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个参数之后，则返回正数。</li>\n</ul>\n<p>操作方法：</p>\n<ul>\n<li><p>concat()方法可以基于当前数组中的所有项创建一个新的数组，他的参数可以传递一个或者多个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"#888\"</span>];</span><br><span class=\"line\">colors.concat(<span class=\"string\">\"#999\"</span>,[<span class=\"string\">\"#333\"</span>,<span class=\"string\">\"#999\"</span>]);<span class=\"comment\">//[\"red\", \"green\", \"#888\", \"#999\", \"#333\", \"#999\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice()方法：它能够基于当前数组的一个或者多个项创建一个新数组。两个参数表示起始位置和结束位置；第二个参数可选</p>\n</li>\n<li><p>splice()方法：可以完成删除、插入和替换：该方法始终返回一个数组，该数组包含从原始数组中删除的项。无删除项则返回空数组。</p>\n<ul>\n<li><p>删除：需要指定两个参数；要删除的第一项的位置和要删除的项数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"yellow\"</span>];</span><br><span class=\"line\">colors.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">//[\"red\", \"green\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>插入：需要提供三个参数，起始位置、删除的项数和插入的任意项数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"yellow\"</span>];</span><br><span class=\"line\">colors.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">\"#999\"</span>,<span class=\"string\">\"#888\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colors);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>替换：可以向指定的位置插入任意数量的项；并指定三个参数：起始位置、要删除的项数和要插入的任意数量的项</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>位置方法：两个位置方法：indexof()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引；其中indexOf()从数组的开头向后查找；lastIndexOf()从数组的末尾向前查找；没有找到则返回-1。</p>\n<p>迭代方法：es5定义了<strong>5</strong>种迭代方法。每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象–影响this的值；传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身；以下是五个迭代方法</p>\n<ul>\n<li><p>every():对数组中的每一项运行给定的函数，如果该函数每一项都返回true；则返回true</p>\n</li>\n<li><p>filter():对数组中的每一项运行给定函数；返回该函数会返回true的项组成的数组</p>\n</li>\n<li><p>forEach():对数组中的每一项运行给定函数，这个方法没有返回值</p>\n</li>\n<li><p>map()：对数组中的每一项运行给定函数；返回每次函数调用的结果返回的数组</p>\n</li>\n<li><p>some(): 对数组中的每一项运行给定函数；如果该函数对数组中的任意一项返回true则返回true</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> everyResult=numArr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(everyResult);</span><br><span class=\"line\"><span class=\"keyword\">var</span> someResult=numArr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someResult);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterResult=numArr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(filterResult);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapResult=numArr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item &gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mapResult);</span><br><span class=\"line\"><span class=\"comment\">//forEach没有返回值；能够对数组的每一项执行操作</span></span><br><span class=\"line\">numArr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>es5新增了两个归并方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项；然后构建一个最终返回的值。reduce()方法从数组的第一项开始；逐个便利到最后；而reduceRight()则从数组的最后一项开始；逐个便利到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和可做为归并基础的初始值（可选）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduceArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">reduceArr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev,cur,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//四个参数分别是前一个结果值、当前值、项的索引和数组对象</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(cur);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev+cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reduceArr.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev,cur,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(cur);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev+cur;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h3><p>通过new Date()来获取当前的时间的字符串；如果要获取特定日期；需要传入表示该日期的毫秒数‘为例；为了简化过程；js提供了两个方法Date.parse()和Date.UTC();</p>\n<p>Date.parse()方法接收一个表示日期的字符串参数；然后尝试根据字符串返回对应的毫秒数；解析不成功则返回NaN</p>\n<p>ES5中添加了Date.now()方法；返回调用该方法时日期和时间的毫秒数；日期做比较时调用valueof方法；日期比较的是毫秒数</p>\n<h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><p>函数其实是对象；每个函数都是Function类型的实例，因此函数名实际上也是指向函数对象的指针。函数声明和函数表达式是有区别的：函数声明在解析时会提升；函数表达式则不会；必须先定义后使用</p>\n<p>在函数内部有两个特殊的对象：arguments和this</p>\n<ul>\n<li><p>arguments拥有一个callee的属性，该属性是个指针，指向拥有这个arguments对象的函数，在非严格模式下使用，例如函数阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num*<span class=\"built_in\">arguments</span>.callee(num<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);<span class=\"comment\">//120</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数的另外一个对象是this：this引用的是函数据以执行的环境对象（在网页的全局作用域中调用函数时this对象引用的就是不window对象</p>\n</li>\n<li><p>在非严格模式下es5规范化了另外一个函数对象的属性：caller属性保存着当前函数的函数的引用；如果在全局作用域中调用当前函数；他的值为null;在严格模式下使用caller或者arguments.callee.caller都会造成错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(outer.caller);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"built_in\">arguments</span>.callee.caller);<span class=\"comment\">//指向函数outer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数还具有length和prototype属性：length属性表示形参的个数，prototype属性是保存他们所有实例方法的真正所在，该属性不可枚举</p>\n</li>\n<li><p>每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途是在特定的作用域中调用函数；并能扩展函数的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.color=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;<span class=\"attr\">color</span>:<span class=\"string\">\"blue\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">sayColor.call(o);</span><br><span class=\"line\">sayColor.call(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es5还定义了bind()方法;该方法会创建一个函数的实例；其this值会被绑定到传给bind()函数的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;<span class=\"attr\">color</span>:<span class=\"string\">\"blue\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> objectColor=sayColor.bind(o);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h3><p>为了便于操作基本类型的值；js引入了三个特殊的引用类型；Boolean、Number和String。</p>\n<p>Number类型提供了一些用于将数值格式化为字符串的方法：</p>\n<ul>\n<li>toFixed()方法会按照指定的小数位返回数值的字符串表示,该方法具有自动舍入的特性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">10.005</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toFixed(<span class=\"number\">2</span>));<span class=\"comment\">//10.01</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>toExponential()方法；该方法返回指数表示法；表示数值的字符串形式;接收一个参数用来表示小数位</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">19</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toExponential(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>toPrecision()可以根据参数的不同用恰当的字符串来表示数值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">99</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><p>String对象的属性和方法也可以在所有的字符串中访问，string类型的每个实例都有length属性，表示字符串包含多少个字符</p>\n<ul>\n<li><p>charAt()和charCodeAt();这两个方法都接收一个表示字符索引位置的参数；charAt()返回给定位置的那个字符。charCodeAt()返回的是索引位置对应的编码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.charAt(<span class=\"number\">2</span>));<span class=\"comment\">//\"l\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.charCodeAt(<span class=\"number\">2</span>))<span class=\"comment\">//108</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()方法的作用同数组的concat方法相同，用于将一个或者多个字符串拼接起来，返回得到的新字符串；</p>\n</li>\n<li><p>基于子字符串创建新字符串的三个方法：slice()、substr()和substring();这三个方法都返回被操作字符串的子字符串，接收一个或者两个参数。第二个参数的区别是slice()和substring()指定的是字符串最后一个字符后边的位置(包头不包尾)。而substring()的第二个参数指定的则是返回字符的个数;如果不传第二个参数则默认截取到最后。这三个方法都对原始字符串无影响</p>\n<p>这三个方法都是可以传入负值的；对负值的解析也不相同：slice()方法会将传入的负值与长度相加，substr()会将负值的第一个参数与长度相加；第二个参数转为0，substring会将所有的负值转为0</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"string\">\"this is a test string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.substring(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.slice(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.substr(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//his</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf()和lastIndexOf();从一个字符串中搜寻给定的字符串，然后返回给定字符串的位置；没找到则返回-1</p>\n</li>\n<li><p>trim()方法；这个方法创建一个字符串的副本，删除前置以及后置的所有空格并返回结果</p>\n</li>\n<li><p>字符串的大小写转换：js中有四个涉及大小写转换的方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocalUpperCase()</p>\n</li>\n<li><p>字符串的模式匹配方法</p>\n<ul>\n<li><p>match()方法，在字符串上调用这个方法本质上与调用RegExp的exec()方法相同，match方法只接收一个参数，要么是个正则表达式，要么是个RegExp对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text=<span class=\"string\">\"cat,bat,sat,fat\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/.at/</span>;</span><br><span class=\"line\"><span class=\"comment\">//与 pattern.exec(text)相同</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> matches=text.match(pattern);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(matches);<span class=\"comment\">//[\"cat\", index: 0, input: \"cat,bat,sat,fat\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>search():该方法的唯一参数与match()相同；返回字符串中第一个匹配项的索引；未找到则返回-1</p>\n</li>\n<li><p>replace()方法：该方法接收两个参数，第一个参数可以是正则表达式或者一个字符串，第二个参数可以是个字符串或者函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text=<span class=\"string\">\"cat,bat,sat,fat\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result=text.replace(<span class=\"string\">\"at\"</span>,<span class=\"string\">\"ond\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);<span class=\"comment\">//cond,bat,sat,fat</span></span><br><span class=\"line\"><span class=\"comment\">//替换所有需要使用正则的全局标志</span></span><br><span class=\"line\">result=text.replace(<span class=\"regexp\">/at/g</span>,<span class=\"string\">\"ond\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);<span class=\"comment\">//cond,bond,sond,fond</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>split()方法：这个方法可以基于指定的分割符将一个字符串分割成多个字符串，并将结果放在数组中；该方法可以接收第二个参数用于截取数组的长度。</p>\n</li>\n<li><p>localeCompare()方法：这个方法比较两个字符串，并返回下列值中的一个</p>\n<ul>\n<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数</li>\n<li>如果字符串等于字符串参数，则返回0</li>\n<li>如果字符串在字母表中的位置排在字符串参数之后，返回一个正数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stringValue=<span class=\"string\">\"yellow\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"brick\"</span>));<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"yellow\"</span>));<span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"zoo\"</span>));<span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。对象是某个特定引用功能的实例</p>\n<h3 id=\"object类型\"><a href=\"#object类型\" class=\"headerlink\" title=\"object类型\"></a>object类型</h3><p>创建object实例的方式有两种：</p>\n<ul>\n<li><p>使用new操作符后跟Object构造函数</p>\n</li>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person=<span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name=<span class=\"string\">\"haohualiangshi\"</span>;</span><br><span class=\"line\">person.age=<span class=\"number\">29</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用对象字面量的表示方法</p>\n</li>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">\"haohualiangshi\"</span>,</span><br><span class=\"line\">  age:<span class=\"number\">25</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象字面量是向函数传递大量可选参数的的首选方式</p>\n</li>\n</ul>\n<h3 id=\"Array类型\"><a href=\"#Array类型\" class=\"headerlink\" title=\"Array类型\"></a>Array类型</h3><p>js中数组的每一项都可以保存不同类型的数据。创建数组的基本方式有两种：使用Array构造函数，使用数组字面量表示法。</p>\n<p>数组的存储方式有栈方法和队列方法：</p>\n<ul>\n<li>栈是一种LIFO（后进先出）的数据结构，栈的操作方法：push()和pop()方法，push方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。而pop方法则从数组末尾移除最后一项；并返回移除的项。</li>\n<li>队列方法的访问规则是FIFO（先进先出）；队列是在列表的末端添加；在列表的前端移除项；其操作是用push方法在数组的末尾添加数组项；用shift方法移除数组的第一项并返回该项；另外数组还提供了unshift方法；其作用与shift方法相反；与push类似；在数组的前端添加任意个数组项并返回新的数组长度，使用shift和unshift方法可以从相反的方向模拟队列.</li>\n</ul>\n<p>数组中定义好的的重排序方法：</p>\n<ul>\n<li>reverse()  :翻转数组项的顺序</li>\n<li>sort()  : 默认情况下sort方法是按升序排序的；注意；sort方法比较的是字符串：sort方法会调用每个数组项的toString；然后进行对比。该函数可以通过传递两个参数进行灵活的排序操作：如果第一个参数位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个参数之后，则返回正数。</li>\n</ul>\n<p>操作方法：</p>\n<ul>\n<li><p>concat()方法可以基于当前数组中的所有项创建一个新的数组，他的参数可以传递一个或者多个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"#888\"</span>];</span><br><span class=\"line\">colors.concat(<span class=\"string\">\"#999\"</span>,[<span class=\"string\">\"#333\"</span>,<span class=\"string\">\"#999\"</span>]);<span class=\"comment\">//[\"red\", \"green\", \"#888\", \"#999\", \"#333\", \"#999\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>slice()方法：它能够基于当前数组的一个或者多个项创建一个新数组。两个参数表示起始位置和结束位置；第二个参数可选</p>\n</li>\n<li><p>splice()方法：可以完成删除、插入和替换：该方法始终返回一个数组，该数组包含从原始数组中删除的项。无删除项则返回空数组。</p>\n<ul>\n<li><p>删除：需要指定两个参数；要删除的第一项的位置和要删除的项数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"yellow\"</span>];</span><br><span class=\"line\">colors.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">//[\"red\", \"green\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>插入：需要提供三个参数，起始位置、删除的项数和插入的任意项数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colors=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"yellow\"</span>];</span><br><span class=\"line\">colors.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">\"#999\"</span>,<span class=\"string\">\"#888\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colors);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>替换：可以向指定的位置插入任意数量的项；并指定三个参数：起始位置、要删除的项数和要插入的任意数量的项</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>位置方法：两个位置方法：indexof()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引；其中indexOf()从数组的开头向后查找；lastIndexOf()从数组的末尾向前查找；没有找到则返回-1。</p>\n<p>迭代方法：es5定义了<strong>5</strong>种迭代方法。每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象–影响this的值；传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身；以下是五个迭代方法</p>\n<ul>\n<li><p>every():对数组中的每一项运行给定的函数，如果该函数每一项都返回true；则返回true</p>\n</li>\n<li><p>filter():对数组中的每一项运行给定函数；返回该函数会返回true的项组成的数组</p>\n</li>\n<li><p>forEach():对数组中的每一项运行给定函数，这个方法没有返回值</p>\n</li>\n<li><p>map()：对数组中的每一项运行给定函数；返回每次函数调用的结果返回的数组</p>\n</li>\n<li><p>some(): 对数组中的每一项运行给定函数；如果该函数对数组中的任意一项返回true则返回true</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> everyResult=numArr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(everyResult);</span><br><span class=\"line\"><span class=\"keyword\">var</span> someResult=numArr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someResult);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterResult=numArr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(filterResult);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapResult=numArr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (item &gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mapResult);</span><br><span class=\"line\"><span class=\"comment\">//forEach没有返回值；能够对数组的每一项执行操作</span></span><br><span class=\"line\">numArr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>es5新增了两个归并方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项；然后构建一个最终返回的值。reduce()方法从数组的第一项开始；逐个便利到最后；而reduceRight()则从数组的最后一项开始；逐个便利到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和可做为归并基础的初始值（可选）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduceArr=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">reduceArr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev,cur,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//四个参数分别是前一个结果值、当前值、项的索引和数组对象</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(cur);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev+cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reduceArr.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev,cur,index,array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(cur);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev+cur;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date类型\"><a href=\"#Date类型\" class=\"headerlink\" title=\"Date类型\"></a>Date类型</h3><p>通过new Date()来获取当前的时间的字符串；如果要获取特定日期；需要传入表示该日期的毫秒数‘为例；为了简化过程；js提供了两个方法Date.parse()和Date.UTC();</p>\n<p>Date.parse()方法接收一个表示日期的字符串参数；然后尝试根据字符串返回对应的毫秒数；解析不成功则返回NaN</p>\n<p>ES5中添加了Date.now()方法；返回调用该方法时日期和时间的毫秒数；日期做比较时调用valueof方法；日期比较的是毫秒数</p>\n<h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><p>函数其实是对象；每个函数都是Function类型的实例，因此函数名实际上也是指向函数对象的指针。函数声明和函数表达式是有区别的：函数声明在解析时会提升；函数表达式则不会；必须先定义后使用</p>\n<p>在函数内部有两个特殊的对象：arguments和this</p>\n<ul>\n<li><p>arguments拥有一个callee的属性，该属性是个指针，指向拥有这个arguments对象的函数，在非严格模式下使用，例如函数阶乘</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num*<span class=\"built_in\">arguments</span>.callee(num<span class=\"number\">-1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);<span class=\"comment\">//120</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数的另外一个对象是this：this引用的是函数据以执行的环境对象（在网页的全局作用域中调用函数时this对象引用的就是不window对象</p>\n</li>\n<li><p>在非严格模式下es5规范化了另外一个函数对象的属性：caller属性保存着当前函数的函数的引用；如果在全局作用域中调用当前函数；他的值为null;在严格模式下使用caller或者arguments.callee.caller都会造成错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">\"use strict\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  inner();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(outer.caller);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"built_in\">arguments</span>.callee.caller);<span class=\"comment\">//指向函数outer</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数还具有length和prototype属性：length属性表示形参的个数，prototype属性是保存他们所有实例方法的真正所在，该属性不可枚举</p>\n</li>\n<li><p>每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途是在特定的作用域中调用函数；并能扩展函数的作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.color=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;<span class=\"attr\">color</span>:<span class=\"string\">\"blue\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">sayColor.call(o);</span><br><span class=\"line\">sayColor.call(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es5还定义了bind()方法;该方法会创建一个函数的实例；其this值会被绑定到传给bind()函数的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color=<span class=\"string\">\"red\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;<span class=\"attr\">color</span>:<span class=\"string\">\"blue\"</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> objectColor=sayColor.bind(o);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h3><p>为了便于操作基本类型的值；js引入了三个特殊的引用类型；Boolean、Number和String。</p>\n<p>Number类型提供了一些用于将数值格式化为字符串的方法：</p>\n<ul>\n<li>toFixed()方法会按照指定的小数位返回数值的字符串表示,该方法具有自动舍入的特性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">10.005</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toFixed(<span class=\"number\">2</span>));<span class=\"comment\">//10.01</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>toExponential()方法；该方法返回指数表示法；表示数值的字符串形式;接收一个参数用来表示小数位</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">19</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toExponential(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>toPrecision()可以根据参数的不同用恰当的字符串来表示数值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num=<span class=\"number\">99</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.toPrecision(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><p>String对象的属性和方法也可以在所有的字符串中访问，string类型的每个实例都有length属性，表示字符串包含多少个字符</p>\n<ul>\n<li><p>charAt()和charCodeAt();这两个方法都接收一个表示字符索引位置的参数；charAt()返回给定位置的那个字符。charCodeAt()返回的是索引位置对应的编码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.charAt(<span class=\"number\">2</span>));<span class=\"comment\">//\"l\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.charCodeAt(<span class=\"number\">2</span>))<span class=\"comment\">//108</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>concat()方法的作用同数组的concat方法相同，用于将一个或者多个字符串拼接起来，返回得到的新字符串；</p>\n</li>\n<li><p>基于子字符串创建新字符串的三个方法：slice()、substr()和substring();这三个方法都返回被操作字符串的子字符串，接收一个或者两个参数。第二个参数的区别是slice()和substring()指定的是字符串最后一个字符后边的位置(包头不包尾)。而substring()的第二个参数指定的则是返回字符的个数;如果不传第二个参数则默认截取到最后。这三个方法都对原始字符串无影响</p>\n<p>这三个方法都是可以传入负值的；对负值的解析也不相同：slice()方法会将传入的负值与长度相加，substr()会将负值的第一个参数与长度相加；第二个参数转为0，substring会将所有的负值转为0</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test=<span class=\"string\">\"this is a test string\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.substring(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.slice(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//hi</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test.substr(<span class=\"number\">1</span>,<span class=\"number\">3</span>));<span class=\"comment\">//his</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>indexOf()和lastIndexOf();从一个字符串中搜寻给定的字符串，然后返回给定字符串的位置；没找到则返回-1</p>\n</li>\n<li><p>trim()方法；这个方法创建一个字符串的副本，删除前置以及后置的所有空格并返回结果</p>\n</li>\n<li><p>字符串的大小写转换：js中有四个涉及大小写转换的方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocalUpperCase()</p>\n</li>\n<li><p>字符串的模式匹配方法</p>\n<ul>\n<li><p>match()方法，在字符串上调用这个方法本质上与调用RegExp的exec()方法相同，match方法只接收一个参数，要么是个正则表达式，要么是个RegExp对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text=<span class=\"string\">\"cat,bat,sat,fat\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/.at/</span>;</span><br><span class=\"line\"><span class=\"comment\">//与 pattern.exec(text)相同</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> matches=text.match(pattern);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(matches);<span class=\"comment\">//[\"cat\", index: 0, input: \"cat,bat,sat,fat\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>search():该方法的唯一参数与match()相同；返回字符串中第一个匹配项的索引；未找到则返回-1</p>\n</li>\n<li><p>replace()方法：该方法接收两个参数，第一个参数可以是正则表达式或者一个字符串，第二个参数可以是个字符串或者函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text=<span class=\"string\">\"cat,bat,sat,fat\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result=text.replace(<span class=\"string\">\"at\"</span>,<span class=\"string\">\"ond\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);<span class=\"comment\">//cond,bat,sat,fat</span></span><br><span class=\"line\"><span class=\"comment\">//替换所有需要使用正则的全局标志</span></span><br><span class=\"line\">result=text.replace(<span class=\"regexp\">/at/g</span>,<span class=\"string\">\"ond\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);<span class=\"comment\">//cond,bond,sond,fond</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>split()方法：这个方法可以基于指定的分割符将一个字符串分割成多个字符串，并将结果放在数组中；该方法可以接收第二个参数用于截取数组的长度。</p>\n</li>\n<li><p>localeCompare()方法：这个方法比较两个字符串，并返回下列值中的一个</p>\n<ul>\n<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数</li>\n<li>如果字符串等于字符串参数，则返回0</li>\n<li>如果字符串在字母表中的位置排在字符串参数之后，返回一个正数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stringValue=<span class=\"string\">\"yellow\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"brick\"</span>));<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"yellow\"</span>));<span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringValue.localeCompare(<span class=\"string\">\"zoo\"</span>));<span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"前端知识点汇总","date":"2017-07-31T14:28:53.000Z","_content":"\n## 前端知识点总结##\n\n### HTML，HTTP,web综合部分###\n\n1.   HTML是一种标记语言；不是编程语言；HTML的标签通常由开始标签和闭合标签，\n\n2.   **HTML5新增的语义元素**\n\n     | header  |    定义文档或节的页眉    |\n     | :-----: | :-------------: |\n     |   nav   |    定义导航链接的容器    |\n     | section |     定义文档中的节     |\n     | article |   定义独立的自包含文章    |\n     |  aside  | 定义内容之外的内容（比如侧栏） |\n     | footer  |    定义文档或节的页脚    |\n     | details |     定义额外的细节     |\n     | summary | 定义details元素的标题  |\n\n3.   常见的排序算法和时间复杂度、空间复杂度。参考图片https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png\n\n4.   **前端需要注意哪些SEO**\n\n     1.   合理的title、description、keywords：搜索对这三项的权重逐渐减小；title强调重点即可；重要的关键词不要超过2次；description把页面高度概括；长度合适；keywords列举出重要关键词即可\n     2.   语义化HTML代码，符合W3C规范\n     3.   重要的HTML代码放在最前边\n     4.   重要内容不要用js输出；爬虫不会执行js获取内容\n     5.   非装饰性图片必须加alt\n     6.   提高网站速度\n     7.   少用iframe\n\n5.   **web开发中会话跟踪的方法**\n\n     1.   cookie：document.cookie = name + \"=\" + escape(value) + \";expires=\"+过期时间（毫秒） + \";path=/\";（作用域）\n     2.   session\n     3.   url重写\n     4.   隐藏input\n     5.   ip地址\n\n6.   **img标签的title和alt的区别 **\n\n     1.   title是global attributes之一，用于为元素提供附加的advisory infomation。通常鼠标移动到元素上的时候显示。\n     2.   alt是img标签的特有属性；是图片内容的描述信息；提高图片的可访问性\n\n7.   **doctype是什么，常见的doctype及特点**\n\n     1.   <!docutype>是文档声明。声明必须处于HTML文档的头部，在html文档之前，html5不区分大小写\n\n     2.   文档声明不是一个Html标签，是一个用于告诉浏览器当前html版本的指令\n\n     3.   现代浏览器的html布局通是通过引擎检查doctype决定使用兼容模式还是标准模式对文档进行渲染\n\n     4.   在html 4.01中doctype声明时指向一个DTD;HTML4.01基于SGML，所以DTD指定了标记规则保证浏览器能够正确渲染。html5不是基于SGML的；因此不用指定DTD\n\n          **常见的doctype**\n\n     *    **HTML4.01 strict**：不允许使用表现性、废弃元素（如font）以及frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n     *    **HTML4.01 Transitional**:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">`\n     *    **HTML4.01 Frameset**:允许表现性元素，废气元素以及frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">`\n     *    **XHTML1.0 Strict**:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：`<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">`\n     *    **XHTML1.0 Transitional**:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： `<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">`\n     *    **XHTML 1.0 Frameset**:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：`<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">`\n     *    **HTML 5**: `<!doctype html>`\n\n     8.   **HTML全局属性（Global attribute）有哪些**\n\n          1.   accesskey:设置快捷键，提供快速访问元素\n          2.   class：为元素设置类标示，多个类名用空格隔开\n          3.   contenteditable：指定元素的内容是否可编辑\n          4.   contextMenu：自定义鼠标右键弹出菜单内容\n          5.   data-*：为元素增加自定义属性\n          6.   dir：设置元素文本fangxiang\n          7.   dragable：设置元素是否可拖拽\n          8.   hidden：表示一个文档是否在文档上显示\n          9.   id：元素id，文档内唯一\n          10.   lang：元素内容的语言\n          11.   spellcheck：是否启动拼写和语法检查\n          12.   style：行内css样式\n          13.   tabindex：设置元素可以获得焦点；通过tab可以导航\n          14.   title：元素相关的建议信息\n          15.   translate：元素和子孙节点内容是否本地化\n\n     9.   **什么是web语义化，有什么好处**\n\n          web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML的语义化是指--通过使用语义化的标签恰当的表示文档结构\n          css的语义化是指--为HTML的标签添加有意义的class，id补充未表达的语义；\n          **语义化的好处** ：\n\n          *    去掉样式后页面呈现清晰的解构\n          *    盲人使用读屏器更好的阅读\n          *    搜索引擎更好地理解页面；有利于收录\n          *    便团队项目的可持续运作及维护\n\n     10.   **HTTP method**\n\n         1.   一台服务器要与HTTP1.1兼容，只要为资源实现get和HEAD方法即可\n         2.   GET是最常用的方法，通常用于**请求服务器发送某个资源**。\n         3.   HEAD与GET类似，但**服务器在响应中值返回首部，不返回实体的主体部分**\n         4.   PUT让服务器**用请求的主体部分来创建一个由所请求的URL命名的新文档，或者如果那个URL已经存在的话，就用这个主体代替它**\n         5.   POST起初是用来向服务器输入数据的。实际上通常会用它来支持HTML的表单，表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方\n         6.   TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹一个TRACE响应并在响应主题中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证是否如愿穿过了请求/响应链。\n         7.   OPTIONS方法请求web服务器告知其支持的各种功能，可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n         8.   DELETE请求服务器删除请求URL指定的资源\n\n     11.   **从浏览器地址栏输入URL到显示页面的步骤(以HTTP为例）**\n\n           1.   在浏览器输入URL\n\n           2.   浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤\n                *    如果资源未缓存，发起新请求\n                *    如果已缓存，检验是否过期，未过期直接供给客户端，否则与服务器进行验证\n                *    检查是否过期通常由两个HTTP头进行控制`Expires`和`Cache-Control`:\n                     *    HTTP1.0提供Expires，值为一个绝对时间表示缓存失效时间\n                     *    HTTP1.1增加了cache-Control:max-age=;值是以秒为单位的最大过期时间\n\n           3.   浏览器解析URL获取协议、主机、端口、路径\n\n           4.   浏览器组装一个HTTP（GET）请求报文\n\n           5.   浏览器获取主机IP地址。过程如下：\n\n                *    浏览器缓存\n                *    本机缓存\n                *    hosts文件\n                *    路由器缓存\n                *    ISP DNS缓存\n                *    DNS递归查询（可能存在负载均衡导致每次IP不一样）\n\n           6.   打开一个socket与目标ip地址，端口建立TCP连接，三次握手如下\n\n                *    客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口\n                *    服务器发回SYN=1，ACK=x+1，Seq=y的响应包\n                *    客户端发送ACK=Y+1，Seq=Z\n\n           7.   TCP连接建立后发送HTTP请求\n\n           8.   服务器接收请求并解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序\n\n           9.   服务器检查HTTP请求是否包含缓存验证信息，如果验证缓存未过期，返回304等对应状态码\n\n           10.   处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作\n\n           11.   服务器将相应报文通过TCP连接发送回浏览器\n\n           12.   浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用。关闭TCP连接的四次握手如下：\n\n                 *    主动方发送Fin=1，Ack=Z，Seq=X报文\n                 *    被动方发送ACK=X+1，Seq=Z报文\n                 *    被动发发送Fin=1，ACK=X，Seq=Y报文\n                 *    主动方发送ACK=Y,Seq=X报文\n\n           13.   浏览器检查响应状态码：是否为1XX,3XX,4XX,5XX这些情况处理与2XX不同\n\n           14.   如果资源可缓存，进行缓存\n\n           15.   对响应进行解码\n\n           16.   根据资源的类型决定如何处理\n\n           17.   解析HTML,构建DOM树，下载资源，构建cssDom树，执行js脚本，这些操作没有严格的先后顺序\n\n           18.   构建DOM树\n\n                 *    Tokenizing：根据HTML规范将字符流解析为标记\n                 *    lexing：词法分析将标记转换为对象定义属性和规则\n                 *    DOM construction：根据HTML标记关系将对象组成Dom树\n\n           19.   解析过程中遇到图片、样式表、js文件，启动下载\n\n           20.   构建cssDom树\n\n                 *    从DOM树的根节点遍历所有的可见节点，不可见节点包括：(1)`script`和`meta`标签 (2)被css隐藏的节点\n                 *    对每一个可见节点，找到恰当的cssDom并应用\n                 *    发布可视节点的内容和计算样式\n\n           21.   js解析如下;\n\n                 1.   浏览器创建document对象并解析HTML，将解析到的元素和文本节点添加到文档中。此时document.readystate为loading\n                 2.   HTML遇到没有async和defer的script时；将他们添加到文档中然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停\n                 3.   当解析器遇到设置了async属性的script时；开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行；但是解析器不会停下来等它下载；异步脚本禁止使用document.write()\n                 4.   当文档完成解析，document.readstate变成interactive\n                 5.   所有defer脚本会按照在文档出现的顺序执行；延迟脚本嫩访问完整文档树；禁止使用document.write()\n                 6.   浏览器在Document对象上触发DomContentLoaded事件\n                 7.   此时文档完全解析完成；浏览器可能还在等待图片等内容加载；等这些内容完成载入并且所有异步脚本载入和执行。document.readyState状态变为complete。window触发load事件\n                 8.   显示页面\n\n           22.   **http request报文解构**\n\n                 1.   首行是Request-Line包括：请求方法、请求URI、协议版本、CRLF\n\n                 2.   首行之后是若干行请求头，包括general-header、request-header或者entity-header，每一行以CRLF结束\n\n                 3.   请求头和消息实体之间有一个CRLF分隔、\n\n                 4.   根据实际请求需要可能包含一个消息实体；一个请求报文例子如下\n\n                      ~~~\n                      GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\n                      Host: www.w3.org\n                      Connection: keep-alive\n                      Cache-Control: max-age=0\n                      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n                      User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n                      Referer: https://www.google.com.hk/\n                      Accept-Encoding: gzip,deflate,sdch\n                      Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\n                      Cookie: authorstyle=yes\n                      If-None-Match: \"2cc8-3e3073913b100\"\n                      If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\n                      name=qiu&age=25\n                      ~~~\n\n           23.   **HTTP response报文结构是怎样的**\n\n                 1.   行首的状态行包括：**HTTP版本，状态码，状态描述，**后边跟一个CRLF\n\n                 2.   行首之后是若干行响应头，**包括：通用头部，响应头部，实体头部**\n\n                 3.   响应头部和响应实体之间用一个CRLF空行分隔\n\n                 4.   最后是一个可能的消息实体；响应报文例子如下：\n\n                      ~~~\n                      HTTP/1.1 200 OK\n                      Date: Tue, 08 Jul 2014 05:28:43 GMT\n                      Server: Apache/2\n                      Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT\n                      ETag: \"40d7-3e3073913b100\"\n                      Accept-Ranges: bytes\n                      Content-Length: 16599\n                      Cache-Control: max-age=21600\n                      Expires: Tue, 08 Jul 2014 11:28:43 GMT\n                      P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\n                      Content-Type: text/html; charset=iso-8859-1\n\n                      {\"name\": \"qiu\", \"age\": 25}\n                      ~~~\n\n           24.   **如何进行网站性能优化**\n\n                 *    content方面\n                      1.   减少HTTP请求：合并文件，图标类文件或复用小图使用精灵图，\n                      2.   减少DNS查询：DNS查询之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分不到恰当数量的主机名\n                      3.   避免重定向；使ajax可缓存\n                      4.   非必须组件采用延迟加载；未来所需组件预加载\n                      5.   减少DOM元素数量\n                      6.   将资源放在不同的域下：浏览器同时从同一个域下下载的资源有限；增加域可以提高并行下载量\n                      7.   减少iframe数量\n                      8.   不要出现404\n                 *    server方面\n                      1.   使用CDN\n                      2.   添加Expires或者Cache-Control响应头\n                      3.   对组件使用Gzip压缩\n                      4.   配置Etag\n                      5.   ajax使用get请求\n                      6.   避免空src的请标签\n                 *    cookie方面\n                      1.   减小cookie大小\n                      2.   引入资源的域名不要包含cookie\n                 *    css方面\n                      1.   将样式表放到页面顶部\n                      2.   不使用css样式表\n                      3.   不使用@import！\n                      4.   不使用IE的filter\n                 *    js方面\n                      1.   将脚本放入页面的底部\n                      2.   将js和css从外部引入\n                      3.   压缩js和css；删除不需要的脚本\n                      4.   减少DOM访问\n                      5.   合理设计事件监听器\n                 *    图片方面\n                      1.   优化图片：根据实际颜色需要选择色深、压缩\n                      2.   优化css精灵\n                      3.   不要在HTML中拉伸图片\n                      4.   保证favicon.icon小并且可缓存\n                 *    移动方面\n                      1.   保证组件小于25k\n                      2.   pack component into a Multipart Document 将项目分为多个组件\n\n           25.   **什么是渐进增强**\n\n                 渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能；同时为高级浏览器和高宽带用户提供良好的用户体验。核心原则如下：\n\n                 *    所有浏览器都必须能访问基本内容\n                 *    所有浏览器都必须能使用基本功能\n                 *    所有内容都包含在语义化标签中\n                 *    通过外部css提供增强布局\n                 *    通过非侵入式、外部js提供增强功能\n                 *    终端用户web浏览器的个人偏好\n\n           26.   **HTTP状态码及其含义**\n\n                 1.   1XX：信息状态码\n                      *    100 Continue:客户端应当继续发请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且未被拒绝\n                      *    101：服务器已经理解客户端的请求\n                 2.   2XX：成功状态码\n                      *    200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回\n                      *    201 Create：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出他的URL。\n                      *     202 Accepted;请求正在被执行，但还没有处理完\n                      *    203 Non-Authoritative Information:\n                      *    204 No Content ; \n                      *    205 Reset Content\n                      *    Partial Content\n                 3.   3XX : 重定向\n                      *    300 Multiple Choice : 表示请求的文档可以在多个地方找到，并将在返回的文档中列出来；如果服务器有首选设置；首选项将会被列于定位响应头的信息中\n                      *    301 Moved Permanently 请求的文档在别的地方；文档新的URL会在定位响应头中给出。浏览器会自动连接到新的URL\n                      *    302 Found 与301类似，只是定位信息中所给的URL是临时地址；而不是永久的改变地址\n                      *    303 see Other\n                      *    304 Not Modified\n                      *    305 Use Proxy\n                      *    306 \n                      *    307  Temporary Redirect\n                 4.   4XX\n                      *    400 Bad Request\n                      *    401 Unauthorized\n                      *    402 Payment Required\n                      *    403 Forbidden\n                      *    404 Not Found\n                      *    405 Method Not Allowed\n                 5.    5XX\n                      *    500 Internal Server Error\n                      *    501 Not Implemented\n                      *    502 Bad Gateway\n                      *    503 Service Unavailable\n                      *    504 GateWay Timeout\n\n\n### css选择部分\n\n 1.  **CSS选择器有哪些**\n\n     1.   `*`通用选择器：选择所有的元素，不参与计算优先级，兼容IE6+\n     2.   `#id`id选择器：选择id值为id的元素，兼容性IE6+\n     3.   `.X`类选择器：选择class包含x的元素，兼容性IE6+\n     4.   `X Y`后代选择器：选择满足x选择器的后代节点中满足Y选择器的元素；兼容IE6+\n     5.   `tag name`元素选择器：选择所有标签为x的元素；兼容IE6\n     6.   `.link, :visited, :focus, :hover, :active`选择特定状态的链接元素，兼容IE4+\n     7.   `X+Y`直接兄弟选择器：在x之后的第一个兄弟节点中选择满足Y选择器的元素，兼容IE7+\n     8.   `X>Y`子选择器：选择x的子元素中满足y选择器的元素，兼容IE7\n     9.   `X~Y`兄弟选择器：选择x之后的所有兄弟节点中满足x选择器的元素，兼容性IE7+\n     10.   [attr]：选择所有设置了attr属性的元素，兼容IE7\n     11.   [attr=value]：选择属性值刚好等于value的元素\n     12.   [attr~=value]：选择属性值刚好为空白符分隔，其中一个值刚好是value的元素\n     13.   [attr|=value]：选择属性值刚好为value或者value开头的元素\n     14.   [attr^=value]：选择属性值以value开头的元素\n     15.   [attr$=value]：选择属性值以value结尾的元素\n     16.   [attr=value]*：选择属性值中包包含value的元素\n     17.   [:checked]：选择单选框、复选框、下拉框中选中状态下的元素，兼容IE9+\n     18.   `X:after， x::after`：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），css3中`::`表示伪元素。兼容性：`:after`为IE8+`::after`为IE9+\n     19.   `:hover`：鼠标移入状态的元素，兼容性a标签IE4+，所有元素IE7+\n     20.   `:not(selector)`：选择不符合selector的元素。不参与计算优先级，兼容IE9+\n     21.   `::first-letter`:伪元素，选择块元素的第一行的第一个字母。兼容IE5.5+\n     22.   `::first-line`：伪元素，选择块元素的第一行；兼容性IE5.5+\n     23.   `:nth-child(an+b)`：伪类，选择前边有an+b-1个兄弟节点的元素，其中n>=0，兼容性IE9+\n     24.   `:nth-last-child(an+b)`：伪类，选择后边有an+b-1个兄弟节点的元素，其中n>=0，兼容性IE9+\n     25.   `X:nth-of-type(an+b)`：伪类，X为选择器，解析得到的元素标签，选择前边有an+b-1个相同标签兄弟节点的元素；兼容性IE9+\n     26.   `X:nth-last-of-type(an+b)`：伪类，x为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟的元素；兼容性IE9+\n     27.   `X:first-child`：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的第一个子元素。兼容IE7+\n     28.   `X:last-child`：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的最后一个子元素。兼容IE9+\n     29.   `X:only-child`：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容IE9+\n     30.   `X:only-of-type`：伪类，选择x选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点是选中它，兼容性IE9+\n     31.   `X：first-of-type`：伪类，选择X选择的元素，解析得到元素标签，如果该元素此类型元素的第一个元素，选中它；兼容IE9+\n\n\t2. **css sprite是什么，有什么优缺点**\n\n    概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案\n\n    **优点**\n\n     \t1. 减少HTTP请求，极大的提高页面的加载速度\n     \t2. 增加图片信息重复度，提高压缩比，减小图片大小\n     \t3. 更换风格方便；只需在一张或者几张图片上修改颜色或者样式即可实现\n\n    **缺点**\n\n     \t1. 图片合并麻烦\n     \t2. 维护麻烦，修改一个图片可能需要从新布局整个图片样式\n\n 3.  **display：none;与visibility：hidden**的区别\n\n     他们都是让元素不可见；区别\n\n     1.   display:none;会让元素完全从渲染树中消失，渲染的时候不占用任何空间；visibility:hidden不会让元素从渲染树中消失，设置该属性的元素会继续占用空间；只是内容不可见\n     2.   display:none是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden是继承属性；子孙节点的消失是继承了hidden属性值；通过设置`visibility:visible`可以让子孙节点显示\n     3.   修改常规流中元素的display通常会造成文档重排。修改visibility只会引起本元素的重绘\n     4.   读屏器不会读取设置display:none属性值的内容，会读取visibility:hidden元素内容\n\n\t4. **css hack原理及常用的hack技术**\n\n    原理:利用不同浏览器对css的支持和解析结果不一样编写针对特定浏览器样式；常见的hack样式（1）属性hack（2）选择器hack（3）IE条件注释\n\n    *    IE条件注释:适用于IE5-IE9,常见的格式如下\n\n         ~~~\n         <!--[if IE 6]>\n         Special instructions for IE 6 here\n         <![endif]-->\n         ~~~\n\n    *    选择器hack:不同浏览器对选择器的支持不一样\n\n         ~~~\n         /***** Selector Hacks ******/\n\n         /* IE6 and below */\n         * html #uno  { color: red }\n\n         /* IE7 */\n         *:first-child+html #dos { color: red }\n\n         /* IE7, FF, Saf, Opera  */\n         html>body #tres { color: red }\n\n         /* IE8, FF, Saf, Opera (Everything but IE 6,7) */\n         html>/**/body #cuatro { color: red }\n\n         /* Opera 9.27 and below, safari 2 */\n         html:first-child #cinco { color: red }\n\n         /* Safari 2-3 */\n         html[xmlns*=\"\"] body:last-child #seis { color: red }\n\n         /* safari 3+, chrome 1+, opera9+, ff 3.5+ */\n         body:nth-of-type(1) #siete { color: red }\n\n         /* safari 3+, chrome 1+, opera9+, ff 3.5+ */\n         body:first-of-type #ocho {  color: red }\n\n         /* saf3+, chrome1+ */\n         @media screen and (-webkit-min-device-pixel-ratio:0) {\n          #diez  { color: red  }\n         }\n\n         /* iPhone / mobile webkit */\n         @media screen and (max-device-width: 480px) {\n          #veintiseis { color: red  }\n         }\n\n         /* Safari 2 - 3.1 */\n         html[xmlns*=\"\"]:root #trece  { color: red  }\n\n         /* Safari 2 - 3.1, Opera 9.25 */\n         *|html[xmlns*=\"\"] #catorce { color: red  }\n\n         /* Everything but IE6-8 */\n         :root *> #quince { color: red  }\n\n         /* IE7 */\n         *+html #dieciocho {  color: red }\n\n         /* Firefox only. 1+ */\n         #veinticuatro,  x:-moz-any-link  { color: red }\n\n         /* Firefox 3.0+ */\n         #veinticinco,  x:-moz-any-link, x:default  { color: red  }\n         ~~~\n\n    *    属性hack:不同浏览器解析bug或方法\n\n         ~~~\n         /* IE6 */\n         #once { _color: blue }\n\n         /* IE6, IE7 */\n         #doce { *color: blue; /* or #color: blue */ }\n\n         /* Everything but IE6 */\n         #diecisiete { color/**/: blue }\n\n         /* IE6, IE7, IE8 */\n         #diecinueve { color: blue\\9; }\n\n         /* IE7, IE8 */\n         #veinte { color/*\\**/: blue\\9; }\n\n         /* IE6, IE7 -- acts as an !important */\n         #veintesiete { color: blue !ie; } /* string after ! can be anything */\n         ~~~\n\n\t5. **specified value,computed value,use value计算方法**\n\n    *    specified value：计算方法如下：\n         *    如果样式表设置了一个值；使用这个值\n         *    如果没有设置值；这个属性是继承属性，从父元素继承\n         *    如果没有设置值且没有继承；则使用css属性规范指定的初始值\n    *    computed value：以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，computed value的主要作用是用于继承\n    *    used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值的单位为元素；以下属性依赖于布局\n         *    background-position\n         *    bottom,left,right,top\n         *    height,width\n         *    margin值,padding值\n         *    min-height,min-width\n         *    text-indent\n\n\t6. **link与@import的区别**\n\n    \t1. link是HTML方式，@import是css方式\n    \t2. link最大限度支持并行下载，@import过多嵌套导致串行下载，\n    \t3. link可以通过rel=“alternate stylesheet\"指定候选样式\n    \t4. 浏览器支持link早于@import，可以使用@import对老浏览器隐藏样式\n    \t5. @import必须在样式规则之前；可以在css文件中引用其他文件\n\n\t7. **`display:block`和`display:inline`的区别**\n\n    \t1. block元素特点\n        处于常规流中，如果`width`没有设置，会自动填充满父容器；可以使用margin、padding值；在没有设置高度的情况下会扩展高度以包含常规流中的子元素；处于常规流中布局时在前后元素位置之间独立；忽略`vertical-align:inline`元素特点\n    \t2. inline元素特点\n        水平方向上根据direction依次布局；不会在元素前后进行换行；受`white-space`控制；使用margin、padding在竖直方向无效；width/height属性对非替换行内元素无效，宽度由元素内容决定；非替换元素的行框高由line-height确定，替换行呢元素的行框高由height，margin，padding，border决定；浮动或绝对定位时会转化为block；vertical-align属性无效\n\n\t8. **PNG,GIF,JPG格式的区别及如何选择**\n\n    \t1. gif\n        *    8位像素，256色\n        *    无损压缩\n        *    支持简单动画\n        *    支持boolean透明\n        *    适合简单动画\n    \t2. JPEG\n        *    颜色限于256\n        *    有损压缩\n        *    可控制压缩质量\n        *    不支持透明\n        *    适合照片\n    \t3. PNG\n        *    有PNG8和trueColorPNG\n        *    png8类似GIF颜色上线为256，文件小，支持alpha透明，无动画\n        *    适合图标，背景，按钮\n\n\t9. **css有哪些继承属性**\n\n    *    font-size、font-color、font-family\n    *    word-break\n    *    letter-spacing\n    *    text-align\n    *    line-height\n    *    color\n    *    visibility\n    *    cursor\n\n\t10. **IE6浏览器有哪些常见的bug，缺陷或者与标准不一致的地方；如何解决**\n\n     \t1. IE6不支持line-height;解决方法使用css hack\n\n         ~~~\n         .target {\n             min-height: 100px;\n             height: auto !important;\n             height: 100px;   // IE6下内容高度超过会自动扩展高度\n         }\n         ~~~\n\n     \t2. `ol>li`的序号全为1，不递增；解决方法：为`li`设置样式`display:list-item`;\n\n     \t3. 未定位父元素`overflow:auto`,包含`position:relative`子元素，子元素高于父元素时会溢出。解决方法：（1）子元素去掉定位属性（2）不能为子元素去掉定位时；父元素`position:relative`\n\n         ~~~\n         <style type=\"text/css\">\n         .outer {\n             width: 215px;\n             height: 100px;\n             border: 1px solid red;\n             overflow: auto;\n             position: relative;  /* 修复bug */\n         }\n         .inner {\n             width: 100px;\n             height: 200px;\n             background-color: purple;\n             position: relative;\n         }\n         </style>\n\n         <div class=\"outer\">\n             <div class=\"inner\"></div>\n         </div>\n         ~~~\n\n     \t4. IE6只支持a标签的`:hover`伪类，解决方法：使用js为元素添加监听mouseenter、mouseleave事件\n\n     \t5. IE5-IE8不支持`opacity`,解决方法：\n\n         ~~~\n         .opacity {\n             opacity: 0.4\n             filter: alpha(opacity=60); /* for IE5-7 */\n             -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)\"; /* for IE 8*/\n         }\n         ~~~\n\n     \t6. IE6在设置height小于font-size时高度为font-size；解决方法：font-size：0\n\n     \t7. IE6不支持PNG透明背景；解决方法；IE6下使用gif图片\n\n     \t8. IE6-7不支持display：inline-block解决办法：设置inline并处罚hasLayout\n\n         ~~~\n             display: inline-block;\n             *display: inline;\n             *zoom: 1;\n         ~~~\n\n     \t9. IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决方法：（1）使用padding控制间距（2）浮动元素`display:inline`这样解决问题无任何副作用；css标准规定浮动元素会自动转为block\n\n     \t10. 通过为块级元素设置宽度和左右margin值为auto时；IE6不能实现水平居中；解决方法，为父元素设置`text-align:center`\n\n\t11. **容器包含若干浮动元素时如何清理浮动**\n\n     \t1. 容器元素闭合标签前添加额外元素并设置clear：both属性\n\n     \t2. 父元素触发块级格式化上下文\n\n     \t3. 设置容器元素伪元素进行清理\n\n         ~~~\n         /**\n         * 在标准浏览器下使用\n         * 1 content内容为空格用于修复opera下文档中出现\n         *   contenteditable属性时在清理浮动元素上下的空白\n         * 2 使用display使用table而不是block：可以防止容器和\n         *   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7\n         *   zoom: 1;一致\n         **/\n\n         .clearfix:before,\n         .clearfix:after {\n             content: \" \"; /* 1 */\n             display: table; /* 2 */\n         }\n\n         .clearfix:after {\n             clear: both;\n         }\n\n         /**\n         * IE 6/7下使用\n         * 通过触发hasLayout实现包含浮动\n         **/\n         .clearfix {\n             *zoom: 1;\n         }\n         ~~~\n\n\t12. **如何创建块级格式化上下文，BFC有什么用**\n\n     创建规则：\n\n     1.   根元素\n     2.   浮动元素\n     3.   绝对定位元素\n     4.   `display`取值为`inline-block,table-cell,table-caption,flex,inline-flex`之一的元素\n     5.   `over`不是visible的元素\n\n     作用：\n\n     ​\t可以包含浮动元素，不被浮动元素覆盖，阻止父子元素的margin折叠\n\n\t13. **display，float，position的关系**\n\n     \t1. 如果display为none，那么position和float都不起作用\n     \t2. 否则，如果position值为absolute或者fixed；框就是定位的；float的计算值为none\n     \t3. 否则，如果float是不none；框是浮动的\n\n\t14. **外边距折叠**\n\n     毗邻的两个或者多个margin会合并成一个margin；叫做外边距折叠。规则如下：\n\n     \t1. 两个或者多个毗邻的普通流中块元素垂直方向的margin值折叠\n     \t2. 浮动元素、inline-block元素、绝对定位元素的margin值不会和垂直方向的其他元素的margin折叠\n     \t3. 创建了块级格式化上下文的元素，不会和他的子元素发生margin折叠\n     \t4. 元素自身的margin-bottom和margin-top相邻时也会折叠\n\n\t15. **如何确定一个元素的包含块**\n\n     \t1. 根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同；对于paged media，他的尺寸等于page area。初始包含块的direction属性与根元素相同\n     \t2. `position`为`relative`或者`static`的元素；他的包含块由最近的块级（display为block/list-item/table）祖先元素到内容框组成\n     \t3. 如果元素position为fixed。对于连续媒体；它的包含块为viewport；对于paged media；包含块为page area\n     \t4. 如果元素的position为absolute；它的包含块由祖先元素中祖先元素中最近一个position为relative、absolute、或者fixed的元素产生；如果找不到定位的元素；包含块为初始包含块\n\n\t16. **如何水平居中一个元素**\n\n     \t1. 如果需要居中\n\n\n\n### css ###\n\n### JS###\n\n","source":"_posts/前端知识点汇总.md","raw":"---\ntitle: 前端知识点汇总\ndate: 2017-07-31 22:28:53\ntags: [html]\ncategories: 总结\n---\n\n## 前端知识点总结##\n\n### HTML，HTTP,web综合部分###\n\n1.   HTML是一种标记语言；不是编程语言；HTML的标签通常由开始标签和闭合标签，\n\n2.   **HTML5新增的语义元素**\n\n     | header  |    定义文档或节的页眉    |\n     | :-----: | :-------------: |\n     |   nav   |    定义导航链接的容器    |\n     | section |     定义文档中的节     |\n     | article |   定义独立的自包含文章    |\n     |  aside  | 定义内容之外的内容（比如侧栏） |\n     | footer  |    定义文档或节的页脚    |\n     | details |     定义额外的细节     |\n     | summary | 定义details元素的标题  |\n\n3.   常见的排序算法和时间复杂度、空间复杂度。参考图片https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png\n\n4.   **前端需要注意哪些SEO**\n\n     1.   合理的title、description、keywords：搜索对这三项的权重逐渐减小；title强调重点即可；重要的关键词不要超过2次；description把页面高度概括；长度合适；keywords列举出重要关键词即可\n     2.   语义化HTML代码，符合W3C规范\n     3.   重要的HTML代码放在最前边\n     4.   重要内容不要用js输出；爬虫不会执行js获取内容\n     5.   非装饰性图片必须加alt\n     6.   提高网站速度\n     7.   少用iframe\n\n5.   **web开发中会话跟踪的方法**\n\n     1.   cookie：document.cookie = name + \"=\" + escape(value) + \";expires=\"+过期时间（毫秒） + \";path=/\";（作用域）\n     2.   session\n     3.   url重写\n     4.   隐藏input\n     5.   ip地址\n\n6.   **img标签的title和alt的区别 **\n\n     1.   title是global attributes之一，用于为元素提供附加的advisory infomation。通常鼠标移动到元素上的时候显示。\n     2.   alt是img标签的特有属性；是图片内容的描述信息；提高图片的可访问性\n\n7.   **doctype是什么，常见的doctype及特点**\n\n     1.   <!docutype>是文档声明。声明必须处于HTML文档的头部，在html文档之前，html5不区分大小写\n\n     2.   文档声明不是一个Html标签，是一个用于告诉浏览器当前html版本的指令\n\n     3.   现代浏览器的html布局通是通过引擎检查doctype决定使用兼容模式还是标准模式对文档进行渲染\n\n     4.   在html 4.01中doctype声明时指向一个DTD;HTML4.01基于SGML，所以DTD指定了标记规则保证浏览器能够正确渲染。html5不是基于SGML的；因此不用指定DTD\n\n          **常见的doctype**\n\n     *    **HTML4.01 strict**：不允许使用表现性、废弃元素（如font）以及frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">`\n     *    **HTML4.01 Transitional**:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">`\n     *    **HTML4.01 Frameset**:允许表现性元素，废气元素以及frameset。声明：`<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">`\n     *    **XHTML1.0 Strict**:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：`<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">`\n     *    **XHTML1.0 Transitional**:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： `<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">`\n     *    **XHTML 1.0 Frameset**:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：`<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">`\n     *    **HTML 5**: `<!doctype html>`\n\n     8.   **HTML全局属性（Global attribute）有哪些**\n\n          1.   accesskey:设置快捷键，提供快速访问元素\n          2.   class：为元素设置类标示，多个类名用空格隔开\n          3.   contenteditable：指定元素的内容是否可编辑\n          4.   contextMenu：自定义鼠标右键弹出菜单内容\n          5.   data-*：为元素增加自定义属性\n          6.   dir：设置元素文本fangxiang\n          7.   dragable：设置元素是否可拖拽\n          8.   hidden：表示一个文档是否在文档上显示\n          9.   id：元素id，文档内唯一\n          10.   lang：元素内容的语言\n          11.   spellcheck：是否启动拼写和语法检查\n          12.   style：行内css样式\n          13.   tabindex：设置元素可以获得焦点；通过tab可以导航\n          14.   title：元素相关的建议信息\n          15.   translate：元素和子孙节点内容是否本地化\n\n     9.   **什么是web语义化，有什么好处**\n\n          web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML的语义化是指--通过使用语义化的标签恰当的表示文档结构\n          css的语义化是指--为HTML的标签添加有意义的class，id补充未表达的语义；\n          **语义化的好处** ：\n\n          *    去掉样式后页面呈现清晰的解构\n          *    盲人使用读屏器更好的阅读\n          *    搜索引擎更好地理解页面；有利于收录\n          *    便团队项目的可持续运作及维护\n\n     10.   **HTTP method**\n\n         1.   一台服务器要与HTTP1.1兼容，只要为资源实现get和HEAD方法即可\n         2.   GET是最常用的方法，通常用于**请求服务器发送某个资源**。\n         3.   HEAD与GET类似，但**服务器在响应中值返回首部，不返回实体的主体部分**\n         4.   PUT让服务器**用请求的主体部分来创建一个由所请求的URL命名的新文档，或者如果那个URL已经存在的话，就用这个主体代替它**\n         5.   POST起初是用来向服务器输入数据的。实际上通常会用它来支持HTML的表单，表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方\n         6.   TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹一个TRACE响应并在响应主题中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证是否如愿穿过了请求/响应链。\n         7.   OPTIONS方法请求web服务器告知其支持的各种功能，可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n         8.   DELETE请求服务器删除请求URL指定的资源\n\n     11.   **从浏览器地址栏输入URL到显示页面的步骤(以HTTP为例）**\n\n           1.   在浏览器输入URL\n\n           2.   浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤\n                *    如果资源未缓存，发起新请求\n                *    如果已缓存，检验是否过期，未过期直接供给客户端，否则与服务器进行验证\n                *    检查是否过期通常由两个HTTP头进行控制`Expires`和`Cache-Control`:\n                     *    HTTP1.0提供Expires，值为一个绝对时间表示缓存失效时间\n                     *    HTTP1.1增加了cache-Control:max-age=;值是以秒为单位的最大过期时间\n\n           3.   浏览器解析URL获取协议、主机、端口、路径\n\n           4.   浏览器组装一个HTTP（GET）请求报文\n\n           5.   浏览器获取主机IP地址。过程如下：\n\n                *    浏览器缓存\n                *    本机缓存\n                *    hosts文件\n                *    路由器缓存\n                *    ISP DNS缓存\n                *    DNS递归查询（可能存在负载均衡导致每次IP不一样）\n\n           6.   打开一个socket与目标ip地址，端口建立TCP连接，三次握手如下\n\n                *    客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口\n                *    服务器发回SYN=1，ACK=x+1，Seq=y的响应包\n                *    客户端发送ACK=Y+1，Seq=Z\n\n           7.   TCP连接建立后发送HTTP请求\n\n           8.   服务器接收请求并解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序\n\n           9.   服务器检查HTTP请求是否包含缓存验证信息，如果验证缓存未过期，返回304等对应状态码\n\n           10.   处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作\n\n           11.   服务器将相应报文通过TCP连接发送回浏览器\n\n           12.   浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用。关闭TCP连接的四次握手如下：\n\n                 *    主动方发送Fin=1，Ack=Z，Seq=X报文\n                 *    被动方发送ACK=X+1，Seq=Z报文\n                 *    被动发发送Fin=1，ACK=X，Seq=Y报文\n                 *    主动方发送ACK=Y,Seq=X报文\n\n           13.   浏览器检查响应状态码：是否为1XX,3XX,4XX,5XX这些情况处理与2XX不同\n\n           14.   如果资源可缓存，进行缓存\n\n           15.   对响应进行解码\n\n           16.   根据资源的类型决定如何处理\n\n           17.   解析HTML,构建DOM树，下载资源，构建cssDom树，执行js脚本，这些操作没有严格的先后顺序\n\n           18.   构建DOM树\n\n                 *    Tokenizing：根据HTML规范将字符流解析为标记\n                 *    lexing：词法分析将标记转换为对象定义属性和规则\n                 *    DOM construction：根据HTML标记关系将对象组成Dom树\n\n           19.   解析过程中遇到图片、样式表、js文件，启动下载\n\n           20.   构建cssDom树\n\n                 *    从DOM树的根节点遍历所有的可见节点，不可见节点包括：(1)`script`和`meta`标签 (2)被css隐藏的节点\n                 *    对每一个可见节点，找到恰当的cssDom并应用\n                 *    发布可视节点的内容和计算样式\n\n           21.   js解析如下;\n\n                 1.   浏览器创建document对象并解析HTML，将解析到的元素和文本节点添加到文档中。此时document.readystate为loading\n                 2.   HTML遇到没有async和defer的script时；将他们添加到文档中然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停\n                 3.   当解析器遇到设置了async属性的script时；开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行；但是解析器不会停下来等它下载；异步脚本禁止使用document.write()\n                 4.   当文档完成解析，document.readstate变成interactive\n                 5.   所有defer脚本会按照在文档出现的顺序执行；延迟脚本嫩访问完整文档树；禁止使用document.write()\n                 6.   浏览器在Document对象上触发DomContentLoaded事件\n                 7.   此时文档完全解析完成；浏览器可能还在等待图片等内容加载；等这些内容完成载入并且所有异步脚本载入和执行。document.readyState状态变为complete。window触发load事件\n                 8.   显示页面\n\n           22.   **http request报文解构**\n\n                 1.   首行是Request-Line包括：请求方法、请求URI、协议版本、CRLF\n\n                 2.   首行之后是若干行请求头，包括general-header、request-header或者entity-header，每一行以CRLF结束\n\n                 3.   请求头和消息实体之间有一个CRLF分隔、\n\n                 4.   根据实际请求需要可能包含一个消息实体；一个请求报文例子如下\n\n                      ~~~\n                      GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\n                      Host: www.w3.org\n                      Connection: keep-alive\n                      Cache-Control: max-age=0\n                      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n                      User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n                      Referer: https://www.google.com.hk/\n                      Accept-Encoding: gzip,deflate,sdch\n                      Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\n                      Cookie: authorstyle=yes\n                      If-None-Match: \"2cc8-3e3073913b100\"\n                      If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\n                      name=qiu&age=25\n                      ~~~\n\n           23.   **HTTP response报文结构是怎样的**\n\n                 1.   行首的状态行包括：**HTTP版本，状态码，状态描述，**后边跟一个CRLF\n\n                 2.   行首之后是若干行响应头，**包括：通用头部，响应头部，实体头部**\n\n                 3.   响应头部和响应实体之间用一个CRLF空行分隔\n\n                 4.   最后是一个可能的消息实体；响应报文例子如下：\n\n                      ~~~\n                      HTTP/1.1 200 OK\n                      Date: Tue, 08 Jul 2014 05:28:43 GMT\n                      Server: Apache/2\n                      Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT\n                      ETag: \"40d7-3e3073913b100\"\n                      Accept-Ranges: bytes\n                      Content-Length: 16599\n                      Cache-Control: max-age=21600\n                      Expires: Tue, 08 Jul 2014 11:28:43 GMT\n                      P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\n                      Content-Type: text/html; charset=iso-8859-1\n\n                      {\"name\": \"qiu\", \"age\": 25}\n                      ~~~\n\n           24.   **如何进行网站性能优化**\n\n                 *    content方面\n                      1.   减少HTTP请求：合并文件，图标类文件或复用小图使用精灵图，\n                      2.   减少DNS查询：DNS查询之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分不到恰当数量的主机名\n                      3.   避免重定向；使ajax可缓存\n                      4.   非必须组件采用延迟加载；未来所需组件预加载\n                      5.   减少DOM元素数量\n                      6.   将资源放在不同的域下：浏览器同时从同一个域下下载的资源有限；增加域可以提高并行下载量\n                      7.   减少iframe数量\n                      8.   不要出现404\n                 *    server方面\n                      1.   使用CDN\n                      2.   添加Expires或者Cache-Control响应头\n                      3.   对组件使用Gzip压缩\n                      4.   配置Etag\n                      5.   ajax使用get请求\n                      6.   避免空src的请标签\n                 *    cookie方面\n                      1.   减小cookie大小\n                      2.   引入资源的域名不要包含cookie\n                 *    css方面\n                      1.   将样式表放到页面顶部\n                      2.   不使用css样式表\n                      3.   不使用@import！\n                      4.   不使用IE的filter\n                 *    js方面\n                      1.   将脚本放入页面的底部\n                      2.   将js和css从外部引入\n                      3.   压缩js和css；删除不需要的脚本\n                      4.   减少DOM访问\n                      5.   合理设计事件监听器\n                 *    图片方面\n                      1.   优化图片：根据实际颜色需要选择色深、压缩\n                      2.   优化css精灵\n                      3.   不要在HTML中拉伸图片\n                      4.   保证favicon.icon小并且可缓存\n                 *    移动方面\n                      1.   保证组件小于25k\n                      2.   pack component into a Multipart Document 将项目分为多个组件\n\n           25.   **什么是渐进增强**\n\n                 渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能；同时为高级浏览器和高宽带用户提供良好的用户体验。核心原则如下：\n\n                 *    所有浏览器都必须能访问基本内容\n                 *    所有浏览器都必须能使用基本功能\n                 *    所有内容都包含在语义化标签中\n                 *    通过外部css提供增强布局\n                 *    通过非侵入式、外部js提供增强功能\n                 *    终端用户web浏览器的个人偏好\n\n           26.   **HTTP状态码及其含义**\n\n                 1.   1XX：信息状态码\n                      *    100 Continue:客户端应当继续发请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且未被拒绝\n                      *    101：服务器已经理解客户端的请求\n                 2.   2XX：成功状态码\n                      *    200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回\n                      *    201 Create：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出他的URL。\n                      *     202 Accepted;请求正在被执行，但还没有处理完\n                      *    203 Non-Authoritative Information:\n                      *    204 No Content ; \n                      *    205 Reset Content\n                      *    Partial Content\n                 3.   3XX : 重定向\n                      *    300 Multiple Choice : 表示请求的文档可以在多个地方找到，并将在返回的文档中列出来；如果服务器有首选设置；首选项将会被列于定位响应头的信息中\n                      *    301 Moved Permanently 请求的文档在别的地方；文档新的URL会在定位响应头中给出。浏览器会自动连接到新的URL\n                      *    302 Found 与301类似，只是定位信息中所给的URL是临时地址；而不是永久的改变地址\n                      *    303 see Other\n                      *    304 Not Modified\n                      *    305 Use Proxy\n                      *    306 \n                      *    307  Temporary Redirect\n                 4.   4XX\n                      *    400 Bad Request\n                      *    401 Unauthorized\n                      *    402 Payment Required\n                      *    403 Forbidden\n                      *    404 Not Found\n                      *    405 Method Not Allowed\n                 5.    5XX\n                      *    500 Internal Server Error\n                      *    501 Not Implemented\n                      *    502 Bad Gateway\n                      *    503 Service Unavailable\n                      *    504 GateWay Timeout\n\n\n### css选择部分\n\n 1.  **CSS选择器有哪些**\n\n     1.   `*`通用选择器：选择所有的元素，不参与计算优先级，兼容IE6+\n     2.   `#id`id选择器：选择id值为id的元素，兼容性IE6+\n     3.   `.X`类选择器：选择class包含x的元素，兼容性IE6+\n     4.   `X Y`后代选择器：选择满足x选择器的后代节点中满足Y选择器的元素；兼容IE6+\n     5.   `tag name`元素选择器：选择所有标签为x的元素；兼容IE6\n     6.   `.link, :visited, :focus, :hover, :active`选择特定状态的链接元素，兼容IE4+\n     7.   `X+Y`直接兄弟选择器：在x之后的第一个兄弟节点中选择满足Y选择器的元素，兼容IE7+\n     8.   `X>Y`子选择器：选择x的子元素中满足y选择器的元素，兼容IE7\n     9.   `X~Y`兄弟选择器：选择x之后的所有兄弟节点中满足x选择器的元素，兼容性IE7+\n     10.   [attr]：选择所有设置了attr属性的元素，兼容IE7\n     11.   [attr=value]：选择属性值刚好等于value的元素\n     12.   [attr~=value]：选择属性值刚好为空白符分隔，其中一个值刚好是value的元素\n     13.   [attr|=value]：选择属性值刚好为value或者value开头的元素\n     14.   [attr^=value]：选择属性值以value开头的元素\n     15.   [attr$=value]：选择属性值以value结尾的元素\n     16.   [attr=value]*：选择属性值中包包含value的元素\n     17.   [:checked]：选择单选框、复选框、下拉框中选中状态下的元素，兼容IE9+\n     18.   `X:after， x::after`：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），css3中`::`表示伪元素。兼容性：`:after`为IE8+`::after`为IE9+\n     19.   `:hover`：鼠标移入状态的元素，兼容性a标签IE4+，所有元素IE7+\n     20.   `:not(selector)`：选择不符合selector的元素。不参与计算优先级，兼容IE9+\n     21.   `::first-letter`:伪元素，选择块元素的第一行的第一个字母。兼容IE5.5+\n     22.   `::first-line`：伪元素，选择块元素的第一行；兼容性IE5.5+\n     23.   `:nth-child(an+b)`：伪类，选择前边有an+b-1个兄弟节点的元素，其中n>=0，兼容性IE9+\n     24.   `:nth-last-child(an+b)`：伪类，选择后边有an+b-1个兄弟节点的元素，其中n>=0，兼容性IE9+\n     25.   `X:nth-of-type(an+b)`：伪类，X为选择器，解析得到的元素标签，选择前边有an+b-1个相同标签兄弟节点的元素；兼容性IE9+\n     26.   `X:nth-last-of-type(an+b)`：伪类，x为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟的元素；兼容性IE9+\n     27.   `X:first-child`：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的第一个子元素。兼容IE7+\n     28.   `X:last-child`：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的最后一个子元素。兼容IE9+\n     29.   `X:only-child`：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容IE9+\n     30.   `X:only-of-type`：伪类，选择x选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点是选中它，兼容性IE9+\n     31.   `X：first-of-type`：伪类，选择X选择的元素，解析得到元素标签，如果该元素此类型元素的第一个元素，选中它；兼容IE9+\n\n\t2. **css sprite是什么，有什么优缺点**\n\n    概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案\n\n    **优点**\n\n     \t1. 减少HTTP请求，极大的提高页面的加载速度\n     \t2. 增加图片信息重复度，提高压缩比，减小图片大小\n     \t3. 更换风格方便；只需在一张或者几张图片上修改颜色或者样式即可实现\n\n    **缺点**\n\n     \t1. 图片合并麻烦\n     \t2. 维护麻烦，修改一个图片可能需要从新布局整个图片样式\n\n 3.  **display：none;与visibility：hidden**的区别\n\n     他们都是让元素不可见；区别\n\n     1.   display:none;会让元素完全从渲染树中消失，渲染的时候不占用任何空间；visibility:hidden不会让元素从渲染树中消失，设置该属性的元素会继续占用空间；只是内容不可见\n     2.   display:none是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden是继承属性；子孙节点的消失是继承了hidden属性值；通过设置`visibility:visible`可以让子孙节点显示\n     3.   修改常规流中元素的display通常会造成文档重排。修改visibility只会引起本元素的重绘\n     4.   读屏器不会读取设置display:none属性值的内容，会读取visibility:hidden元素内容\n\n\t4. **css hack原理及常用的hack技术**\n\n    原理:利用不同浏览器对css的支持和解析结果不一样编写针对特定浏览器样式；常见的hack样式（1）属性hack（2）选择器hack（3）IE条件注释\n\n    *    IE条件注释:适用于IE5-IE9,常见的格式如下\n\n         ~~~\n         <!--[if IE 6]>\n         Special instructions for IE 6 here\n         <![endif]-->\n         ~~~\n\n    *    选择器hack:不同浏览器对选择器的支持不一样\n\n         ~~~\n         /***** Selector Hacks ******/\n\n         /* IE6 and below */\n         * html #uno  { color: red }\n\n         /* IE7 */\n         *:first-child+html #dos { color: red }\n\n         /* IE7, FF, Saf, Opera  */\n         html>body #tres { color: red }\n\n         /* IE8, FF, Saf, Opera (Everything but IE 6,7) */\n         html>/**/body #cuatro { color: red }\n\n         /* Opera 9.27 and below, safari 2 */\n         html:first-child #cinco { color: red }\n\n         /* Safari 2-3 */\n         html[xmlns*=\"\"] body:last-child #seis { color: red }\n\n         /* safari 3+, chrome 1+, opera9+, ff 3.5+ */\n         body:nth-of-type(1) #siete { color: red }\n\n         /* safari 3+, chrome 1+, opera9+, ff 3.5+ */\n         body:first-of-type #ocho {  color: red }\n\n         /* saf3+, chrome1+ */\n         @media screen and (-webkit-min-device-pixel-ratio:0) {\n          #diez  { color: red  }\n         }\n\n         /* iPhone / mobile webkit */\n         @media screen and (max-device-width: 480px) {\n          #veintiseis { color: red  }\n         }\n\n         /* Safari 2 - 3.1 */\n         html[xmlns*=\"\"]:root #trece  { color: red  }\n\n         /* Safari 2 - 3.1, Opera 9.25 */\n         *|html[xmlns*=\"\"] #catorce { color: red  }\n\n         /* Everything but IE6-8 */\n         :root *> #quince { color: red  }\n\n         /* IE7 */\n         *+html #dieciocho {  color: red }\n\n         /* Firefox only. 1+ */\n         #veinticuatro,  x:-moz-any-link  { color: red }\n\n         /* Firefox 3.0+ */\n         #veinticinco,  x:-moz-any-link, x:default  { color: red  }\n         ~~~\n\n    *    属性hack:不同浏览器解析bug或方法\n\n         ~~~\n         /* IE6 */\n         #once { _color: blue }\n\n         /* IE6, IE7 */\n         #doce { *color: blue; /* or #color: blue */ }\n\n         /* Everything but IE6 */\n         #diecisiete { color/**/: blue }\n\n         /* IE6, IE7, IE8 */\n         #diecinueve { color: blue\\9; }\n\n         /* IE7, IE8 */\n         #veinte { color/*\\**/: blue\\9; }\n\n         /* IE6, IE7 -- acts as an !important */\n         #veintesiete { color: blue !ie; } /* string after ! can be anything */\n         ~~~\n\n\t5. **specified value,computed value,use value计算方法**\n\n    *    specified value：计算方法如下：\n         *    如果样式表设置了一个值；使用这个值\n         *    如果没有设置值；这个属性是继承属性，从父元素继承\n         *    如果没有设置值且没有继承；则使用css属性规范指定的初始值\n    *    computed value：以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，computed value的主要作用是用于继承\n    *    used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值的单位为元素；以下属性依赖于布局\n         *    background-position\n         *    bottom,left,right,top\n         *    height,width\n         *    margin值,padding值\n         *    min-height,min-width\n         *    text-indent\n\n\t6. **link与@import的区别**\n\n    \t1. link是HTML方式，@import是css方式\n    \t2. link最大限度支持并行下载，@import过多嵌套导致串行下载，\n    \t3. link可以通过rel=“alternate stylesheet\"指定候选样式\n    \t4. 浏览器支持link早于@import，可以使用@import对老浏览器隐藏样式\n    \t5. @import必须在样式规则之前；可以在css文件中引用其他文件\n\n\t7. **`display:block`和`display:inline`的区别**\n\n    \t1. block元素特点\n        处于常规流中，如果`width`没有设置，会自动填充满父容器；可以使用margin、padding值；在没有设置高度的情况下会扩展高度以包含常规流中的子元素；处于常规流中布局时在前后元素位置之间独立；忽略`vertical-align:inline`元素特点\n    \t2. inline元素特点\n        水平方向上根据direction依次布局；不会在元素前后进行换行；受`white-space`控制；使用margin、padding在竖直方向无效；width/height属性对非替换行内元素无效，宽度由元素内容决定；非替换元素的行框高由line-height确定，替换行呢元素的行框高由height，margin，padding，border决定；浮动或绝对定位时会转化为block；vertical-align属性无效\n\n\t8. **PNG,GIF,JPG格式的区别及如何选择**\n\n    \t1. gif\n        *    8位像素，256色\n        *    无损压缩\n        *    支持简单动画\n        *    支持boolean透明\n        *    适合简单动画\n    \t2. JPEG\n        *    颜色限于256\n        *    有损压缩\n        *    可控制压缩质量\n        *    不支持透明\n        *    适合照片\n    \t3. PNG\n        *    有PNG8和trueColorPNG\n        *    png8类似GIF颜色上线为256，文件小，支持alpha透明，无动画\n        *    适合图标，背景，按钮\n\n\t9. **css有哪些继承属性**\n\n    *    font-size、font-color、font-family\n    *    word-break\n    *    letter-spacing\n    *    text-align\n    *    line-height\n    *    color\n    *    visibility\n    *    cursor\n\n\t10. **IE6浏览器有哪些常见的bug，缺陷或者与标准不一致的地方；如何解决**\n\n     \t1. IE6不支持line-height;解决方法使用css hack\n\n         ~~~\n         .target {\n             min-height: 100px;\n             height: auto !important;\n             height: 100px;   // IE6下内容高度超过会自动扩展高度\n         }\n         ~~~\n\n     \t2. `ol>li`的序号全为1，不递增；解决方法：为`li`设置样式`display:list-item`;\n\n     \t3. 未定位父元素`overflow:auto`,包含`position:relative`子元素，子元素高于父元素时会溢出。解决方法：（1）子元素去掉定位属性（2）不能为子元素去掉定位时；父元素`position:relative`\n\n         ~~~\n         <style type=\"text/css\">\n         .outer {\n             width: 215px;\n             height: 100px;\n             border: 1px solid red;\n             overflow: auto;\n             position: relative;  /* 修复bug */\n         }\n         .inner {\n             width: 100px;\n             height: 200px;\n             background-color: purple;\n             position: relative;\n         }\n         </style>\n\n         <div class=\"outer\">\n             <div class=\"inner\"></div>\n         </div>\n         ~~~\n\n     \t4. IE6只支持a标签的`:hover`伪类，解决方法：使用js为元素添加监听mouseenter、mouseleave事件\n\n     \t5. IE5-IE8不支持`opacity`,解决方法：\n\n         ~~~\n         .opacity {\n             opacity: 0.4\n             filter: alpha(opacity=60); /* for IE5-7 */\n             -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=60)\"; /* for IE 8*/\n         }\n         ~~~\n\n     \t6. IE6在设置height小于font-size时高度为font-size；解决方法：font-size：0\n\n     \t7. IE6不支持PNG透明背景；解决方法；IE6下使用gif图片\n\n     \t8. IE6-7不支持display：inline-block解决办法：设置inline并处罚hasLayout\n\n         ~~~\n             display: inline-block;\n             *display: inline;\n             *zoom: 1;\n         ~~~\n\n     \t9. IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决方法：（1）使用padding控制间距（2）浮动元素`display:inline`这样解决问题无任何副作用；css标准规定浮动元素会自动转为block\n\n     \t10. 通过为块级元素设置宽度和左右margin值为auto时；IE6不能实现水平居中；解决方法，为父元素设置`text-align:center`\n\n\t11. **容器包含若干浮动元素时如何清理浮动**\n\n     \t1. 容器元素闭合标签前添加额外元素并设置clear：both属性\n\n     \t2. 父元素触发块级格式化上下文\n\n     \t3. 设置容器元素伪元素进行清理\n\n         ~~~\n         /**\n         * 在标准浏览器下使用\n         * 1 content内容为空格用于修复opera下文档中出现\n         *   contenteditable属性时在清理浮动元素上下的空白\n         * 2 使用display使用table而不是block：可以防止容器和\n         *   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7\n         *   zoom: 1;一致\n         **/\n\n         .clearfix:before,\n         .clearfix:after {\n             content: \" \"; /* 1 */\n             display: table; /* 2 */\n         }\n\n         .clearfix:after {\n             clear: both;\n         }\n\n         /**\n         * IE 6/7下使用\n         * 通过触发hasLayout实现包含浮动\n         **/\n         .clearfix {\n             *zoom: 1;\n         }\n         ~~~\n\n\t12. **如何创建块级格式化上下文，BFC有什么用**\n\n     创建规则：\n\n     1.   根元素\n     2.   浮动元素\n     3.   绝对定位元素\n     4.   `display`取值为`inline-block,table-cell,table-caption,flex,inline-flex`之一的元素\n     5.   `over`不是visible的元素\n\n     作用：\n\n     ​\t可以包含浮动元素，不被浮动元素覆盖，阻止父子元素的margin折叠\n\n\t13. **display，float，position的关系**\n\n     \t1. 如果display为none，那么position和float都不起作用\n     \t2. 否则，如果position值为absolute或者fixed；框就是定位的；float的计算值为none\n     \t3. 否则，如果float是不none；框是浮动的\n\n\t14. **外边距折叠**\n\n     毗邻的两个或者多个margin会合并成一个margin；叫做外边距折叠。规则如下：\n\n     \t1. 两个或者多个毗邻的普通流中块元素垂直方向的margin值折叠\n     \t2. 浮动元素、inline-block元素、绝对定位元素的margin值不会和垂直方向的其他元素的margin折叠\n     \t3. 创建了块级格式化上下文的元素，不会和他的子元素发生margin折叠\n     \t4. 元素自身的margin-bottom和margin-top相邻时也会折叠\n\n\t15. **如何确定一个元素的包含块**\n\n     \t1. 根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同；对于paged media，他的尺寸等于page area。初始包含块的direction属性与根元素相同\n     \t2. `position`为`relative`或者`static`的元素；他的包含块由最近的块级（display为block/list-item/table）祖先元素到内容框组成\n     \t3. 如果元素position为fixed。对于连续媒体；它的包含块为viewport；对于paged media；包含块为page area\n     \t4. 如果元素的position为absolute；它的包含块由祖先元素中祖先元素中最近一个position为relative、absolute、或者fixed的元素产生；如果找不到定位的元素；包含块为初始包含块\n\n\t16. **如何水平居中一个元素**\n\n     \t1. 如果需要居中\n\n\n\n### css ###\n\n### JS###\n\n","slug":"前端知识点汇总","published":1,"updated":"2018-11-26T04:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdgsex2000aybf72mlvehvw","content":"<h2 id=\"前端知识点总结\"><a href=\"#前端知识点总结\" class=\"headerlink\" title=\"前端知识点总结\"></a>前端知识点总结</h2><h3 id=\"HTML，HTTP-web综合部分\"><a href=\"#HTML，HTTP-web综合部分\" class=\"headerlink\" title=\"HTML，HTTP,web综合部分\"></a>HTML，HTTP,web综合部分</h3><ol>\n<li><p>HTML是一种标记语言；不是编程语言；HTML的标签通常由开始标签和闭合标签，</p>\n</li>\n<li><p><strong>HTML5新增的语义元素</strong></p>\n<p>| header  |    定义文档或节的页眉    |<br>| :—–: | :————-: |<br>|   nav   |    定义导航链接的容器    |<br>| section |     定义文档中的节     |<br>| article |   定义独立的自包含文章    |<br>|  aside  | 定义内容之外的内容（比如侧栏） |<br>| footer  |    定义文档或节的页脚    |<br>| details |     定义额外的细节     |<br>| summary | 定义details元素的标题  |</p>\n</li>\n<li><p>常见的排序算法和时间复杂度、空间复杂度。参考图片<a href=\"https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png\" target=\"_blank\" rel=\"noopener\">https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png</a></p>\n</li>\n<li><p><strong>前端需要注意哪些SEO</strong></p>\n<ol>\n<li>合理的title、description、keywords：搜索对这三项的权重逐渐减小；title强调重点即可；重要的关键词不要超过2次；description把页面高度概括；长度合适；keywords列举出重要关键词即可</li>\n<li>语义化HTML代码，符合W3C规范</li>\n<li>重要的HTML代码放在最前边</li>\n<li>重要内容不要用js输出；爬虫不会执行js获取内容</li>\n<li>非装饰性图片必须加alt</li>\n<li>提高网站速度</li>\n<li>少用iframe</li>\n</ol>\n</li>\n<li><p><strong>web开发中会话跟踪的方法</strong></p>\n<ol>\n<li>cookie：document.cookie = name + “=” + escape(value) + “;expires=”+过期时间（毫秒） + “;path=/“;（作用域）</li>\n<li>session</li>\n<li>url重写</li>\n<li>隐藏input</li>\n<li>ip地址</li>\n</ol>\n</li>\n<li><p><strong>img标签的title和alt的区别 </strong></p>\n<ol>\n<li>title是global attributes之一，用于为元素提供附加的advisory infomation。通常鼠标移动到元素上的时候显示。</li>\n<li>alt是img标签的特有属性；是图片内容的描述信息；提高图片的可访问性</li>\n</ol>\n</li>\n<li><p><strong>doctype是什么，常见的doctype及特点</strong></p>\n<ol>\n<li><p>&lt;!docutype&gt;是文档声明。声明必须处于HTML文档的头部，在html文档之前，html5不区分大小写</p>\n</li>\n<li><p>文档声明不是一个Html标签，是一个用于告诉浏览器当前html版本的指令</p>\n</li>\n<li><p>现代浏览器的html布局通是通过引擎检查doctype决定使用兼容模式还是标准模式对文档进行渲染</p>\n</li>\n<li><p>在html 4.01中doctype声明时指向一个DTD;HTML4.01基于SGML，所以DTD指定了标记规则保证浏览器能够正确渲染。html5不是基于SGML的；因此不用指定DTD</p>\n<p><strong>常见的doctype</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>HTML4.01 strict</strong>：不允许使用表现性、废弃元素（如font）以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li><strong>HTML4.01 Transitional</strong>:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></li>\n<li><strong>HTML4.01 Frameset</strong>:允许表现性元素，废气元素以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></li>\n<li><strong>XHTML1.0 Strict</strong>:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></li>\n<li><strong>XHTML1.0 Transitional</strong>:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： <code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></li>\n<li><strong>XHTML 1.0 Frameset</strong>:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></li>\n<li><strong>HTML 5</strong>: <code>&lt;!doctype html&gt;</code></li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>HTML全局属性（Global attribute）有哪些</strong></p>\n<ol>\n<li>accesskey:设置快捷键，提供快速访问元素</li>\n<li>class：为元素设置类标示，多个类名用空格隔开</li>\n<li>contenteditable：指定元素的内容是否可编辑</li>\n<li>contextMenu：自定义鼠标右键弹出菜单内容</li>\n<li>data-*：为元素增加自定义属性</li>\n<li>dir：设置元素文本fangxiang</li>\n<li>dragable：设置元素是否可拖拽</li>\n<li>hidden：表示一个文档是否在文档上显示</li>\n<li>id：元素id，文档内唯一</li>\n<li>lang：元素内容的语言</li>\n<li>spellcheck：是否启动拼写和语法检查</li>\n<li>style：行内css样式</li>\n<li>tabindex：设置元素可以获得焦点；通过tab可以导航</li>\n<li>title：元素相关的建议信息</li>\n<li>translate：元素和子孙节点内容是否本地化</li>\n</ol>\n</li>\n<li><p><strong>什么是web语义化，有什么好处</strong></p>\n<p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML的语义化是指–通过使用语义化的标签恰当的表示文档结构<br>css的语义化是指–为HTML的标签添加有意义的class，id补充未表达的语义；<br><strong>语义化的好处</strong> ：</p>\n<ul>\n<li>去掉样式后页面呈现清晰的解构</li>\n<li>盲人使用读屏器更好的阅读</li>\n<li>搜索引擎更好地理解页面；有利于收录</li>\n<li>便团队项目的可持续运作及维护</li>\n</ul>\n</li>\n<li><p><strong>HTTP method</strong></p>\n<ol>\n<li>一台服务器要与HTTP1.1兼容，只要为资源实现get和HEAD方法即可</li>\n<li>GET是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong>。</li>\n<li>HEAD与GET类似，但<strong>服务器在响应中值返回首部，不返回实体的主体部分</strong></li>\n<li>PUT让服务器<strong>用请求的主体部分来创建一个由所请求的URL命名的新文档，或者如果那个URL已经存在的话，就用这个主体代替它</strong></li>\n<li>POST起初是用来向服务器输入数据的。实际上通常会用它来支持HTML的表单，表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方</li>\n<li>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹一个TRACE响应并在响应主题中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS方法请求web服务器告知其支持的各种功能，可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE请求服务器删除请求URL指定的资源</li>\n</ol>\n</li>\n<li><p><strong>从浏览器地址栏输入URL到显示页面的步骤(以HTTP为例）</strong></p>\n<ol>\n<li><p>在浏览器输入URL</p>\n</li>\n<li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>\n<ul>\n<li>如果资源未缓存，发起新请求</li>\n<li>如果已缓存，检验是否过期，未过期直接供给客户端，否则与服务器进行验证</li>\n<li>检查是否过期通常由两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>:<ul>\n<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存失效时间</li>\n<li>HTTP1.1增加了cache-Control:max-age=;值是以秒为单位的最大过期时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>浏览器解析URL获取协议、主机、端口、路径</p>\n</li>\n<li><p>浏览器组装一个HTTP（GET）请求报文</p>\n</li>\n<li><p>浏览器获取主机IP地址。过程如下：</p>\n<ul>\n<li>浏览器缓存</li>\n<li>本机缓存</li>\n<li>hosts文件</li>\n<li>路由器缓存</li>\n<li>ISP DNS缓存</li>\n<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>\n</ul>\n</li>\n<li><p>打开一个socket与目标ip地址，端口建立TCP连接，三次握手如下</p>\n<ul>\n<li>客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口</li>\n<li>服务器发回SYN=1，ACK=x+1，Seq=y的响应包</li>\n<li>客户端发送ACK=Y+1，Seq=Z</li>\n</ul>\n</li>\n<li><p>TCP连接建立后发送HTTP请求</p>\n</li>\n<li><p>服务器接收请求并解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p>\n</li>\n<li><p>服务器检查HTTP请求是否包含缓存验证信息，如果验证缓存未过期，返回304等对应状态码</p>\n</li>\n<li><p>处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作</p>\n</li>\n<li><p>服务器将相应报文通过TCP连接发送回浏览器</p>\n</li>\n<li><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用。关闭TCP连接的四次握手如下：</p>\n<ul>\n<li>主动方发送Fin=1，Ack=Z，Seq=X报文</li>\n<li>被动方发送ACK=X+1，Seq=Z报文</li>\n<li>被动发发送Fin=1，ACK=X，Seq=Y报文</li>\n<li>主动方发送ACK=Y,Seq=X报文</li>\n</ul>\n</li>\n<li><p>浏览器检查响应状态码：是否为1XX,3XX,4XX,5XX这些情况处理与2XX不同</p>\n</li>\n<li><p>如果资源可缓存，进行缓存</p>\n</li>\n<li><p>对响应进行解码</p>\n</li>\n<li><p>根据资源的类型决定如何处理</p>\n</li>\n<li><p>解析HTML,构建DOM树，下载资源，构建cssDom树，执行js脚本，这些操作没有严格的先后顺序</p>\n</li>\n<li><p>构建DOM树</p>\n<ul>\n<li>Tokenizing：根据HTML规范将字符流解析为标记</li>\n<li>lexing：词法分析将标记转换为对象定义属性和规则</li>\n<li>DOM construction：根据HTML标记关系将对象组成Dom树</li>\n</ul>\n</li>\n<li><p>解析过程中遇到图片、样式表、js文件，启动下载</p>\n</li>\n<li><p>构建cssDom树</p>\n<ul>\n<li>从DOM树的根节点遍历所有的可见节点，不可见节点包括：(1)<code>script</code>和<code>meta</code>标签 (2)被css隐藏的节点</li>\n<li>对每一个可见节点，找到恰当的cssDom并应用</li>\n<li>发布可视节点的内容和计算样式</li>\n</ul>\n</li>\n<li><p>js解析如下;</p>\n<ol>\n<li>浏览器创建document对象并解析HTML，将解析到的元素和文本节点添加到文档中。此时document.readystate为loading</li>\n<li>HTML遇到没有async和defer的script时；将他们添加到文档中然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停</li>\n<li>当解析器遇到设置了async属性的script时；开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行；但是解析器不会停下来等它下载；异步脚本禁止使用document.write()</li>\n<li>当文档完成解析，document.readstate变成interactive</li>\n<li>所有defer脚本会按照在文档出现的顺序执行；延迟脚本嫩访问完整文档树；禁止使用document.write()</li>\n<li>浏览器在Document对象上触发DomContentLoaded事件</li>\n<li>此时文档完全解析完成；浏览器可能还在等待图片等内容加载；等这些内容完成载入并且所有异步脚本载入和执行。document.readyState状态变为complete。window触发load事件</li>\n<li>显示页面</li>\n</ol>\n</li>\n<li><p><strong>http request报文解构</strong></p>\n<ol>\n<li><p>首行是Request-Line包括：请求方法、请求URI、协议版本、CRLF</p>\n</li>\n<li><p>首行之后是若干行请求头，包括general-header、request-header或者entity-header，每一行以CRLF结束</p>\n</li>\n<li><p>请求头和消息实体之间有一个CRLF分隔、</p>\n</li>\n<li><p>根据实际请求需要可能包含一个消息实体；一个请求报文例子如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</span><br><span class=\"line\">Host: www.w3.org</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</span><br><span class=\"line\">Referer: https://www.google.com.hk/</span><br><span class=\"line\">Accept-Encoding: gzip,deflate,sdch</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class=\"line\">Cookie: authorstyle=yes</span><br><span class=\"line\">If-None-Match: &quot;2cc8-3e3073913b100&quot;</span><br><span class=\"line\">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">name=qiu&amp;age=25</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>HTTP response报文结构是怎样的</strong></p>\n<ol>\n<li><p>行首的状态行包括：<strong>HTTP版本，状态码，状态描述，</strong>后边跟一个CRLF</p>\n</li>\n<li><p>行首之后是若干行响应头，<strong>包括：通用头部，响应头部，实体头部</strong></p>\n</li>\n<li><p>响应头部和响应实体之间用一个CRLF空行分隔</p>\n</li>\n<li><p>最后是一个可能的消息实体；响应报文例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Tue, 08 Jul 2014 05:28:43 GMT</span><br><span class=\"line\">Server: Apache/2</span><br><span class=\"line\">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class=\"line\">ETag: &quot;40d7-3e3073913b100&quot;</span><br><span class=\"line\">Accept-Ranges: bytes</span><br><span class=\"line\">Content-Length: 16599</span><br><span class=\"line\">Cache-Control: max-age=21600</span><br><span class=\"line\">Expires: Tue, 08 Jul 2014 11:28:43 GMT</span><br><span class=\"line\">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</span><br><span class=\"line\">Content-Type: text/html; charset=iso-8859-1</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>如何进行网站性能优化</strong></p>\n<ul>\n<li>content方面<ol>\n<li>减少HTTP请求：合并文件，图标类文件或复用小图使用精灵图，</li>\n<li>减少DNS查询：DNS查询之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分不到恰当数量的主机名</li>\n<li>避免重定向；使ajax可缓存</li>\n<li>非必须组件采用延迟加载；未来所需组件预加载</li>\n<li>减少DOM元素数量</li>\n<li>将资源放在不同的域下：浏览器同时从同一个域下下载的资源有限；增加域可以提高并行下载量</li>\n<li>减少iframe数量</li>\n<li>不要出现404</li>\n</ol>\n</li>\n<li>server方面<ol>\n<li>使用CDN</li>\n<li>添加Expires或者Cache-Control响应头</li>\n<li>对组件使用Gzip压缩</li>\n<li>配置Etag</li>\n<li>ajax使用get请求</li>\n<li>避免空src的请标签</li>\n</ol>\n</li>\n<li>cookie方面<ol>\n<li>减小cookie大小</li>\n<li>引入资源的域名不要包含cookie</li>\n</ol>\n</li>\n<li>css方面<ol>\n<li>将样式表放到页面顶部</li>\n<li>不使用css样式表</li>\n<li>不使用@import！</li>\n<li>不使用IE的filter</li>\n</ol>\n</li>\n<li>js方面<ol>\n<li>将脚本放入页面的底部</li>\n<li>将js和css从外部引入</li>\n<li>压缩js和css；删除不需要的脚本</li>\n<li>减少DOM访问</li>\n<li>合理设计事件监听器</li>\n</ol>\n</li>\n<li>图片方面<ol>\n<li>优化图片：根据实际颜色需要选择色深、压缩</li>\n<li>优化css精灵</li>\n<li>不要在HTML中拉伸图片</li>\n<li>保证favicon.icon小并且可缓存</li>\n</ol>\n</li>\n<li>移动方面<ol>\n<li>保证组件小于25k</li>\n<li>pack component into a Multipart Document 将项目分为多个组件</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>什么是渐进增强</strong></p>\n<p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能；同时为高级浏览器和高宽带用户提供良好的用户体验。核心原则如下：</p>\n<ul>\n<li>所有浏览器都必须能访问基本内容</li>\n<li>所有浏览器都必须能使用基本功能</li>\n<li>所有内容都包含在语义化标签中</li>\n<li>通过外部css提供增强布局</li>\n<li>通过非侵入式、外部js提供增强功能</li>\n<li>终端用户web浏览器的个人偏好</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码及其含义</strong></p>\n<ol>\n<li>1XX：信息状态码<ul>\n<li>100 Continue:客户端应当继续发请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且未被拒绝</li>\n<li>101：服务器已经理解客户端的请求</li>\n</ul>\n</li>\n<li>2XX：成功状态码<ul>\n<li>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回</li>\n<li>201 Create：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出他的URL。</li>\n<li>202 Accepted;请求正在被执行，但还没有处理完</li>\n<li>203 Non-Authoritative Information:</li>\n<li>204 No Content ; </li>\n<li>205 Reset Content</li>\n<li>Partial Content</li>\n</ul>\n</li>\n<li>3XX : 重定向<ul>\n<li>300 Multiple Choice : 表示请求的文档可以在多个地方找到，并将在返回的文档中列出来；如果服务器有首选设置；首选项将会被列于定位响应头的信息中</li>\n<li>301 Moved Permanently 请求的文档在别的地方；文档新的URL会在定位响应头中给出。浏览器会自动连接到新的URL</li>\n<li>302 Found 与301类似，只是定位信息中所给的URL是临时地址；而不是永久的改变地址</li>\n<li>303 see Other</li>\n<li>304 Not Modified</li>\n<li>305 Use Proxy</li>\n<li>306 </li>\n<li>307  Temporary Redirect</li>\n</ul>\n</li>\n<li>4XX<ul>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>402 Payment Required</li>\n<li>403 Forbidden</li>\n<li>404 Not Found</li>\n<li>405 Method Not Allowed</li>\n</ul>\n</li>\n<li>5XX<ul>\n<li>500 Internal Server Error</li>\n<li>501 Not Implemented</li>\n<li>502 Bad Gateway</li>\n<li>503 Service Unavailable</li>\n<li>504 GateWay Timeout</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"css选择部分\"><a href=\"#css选择部分\" class=\"headerlink\" title=\"css选择部分\"></a>css选择部分</h3><ol>\n<li><p><strong>CSS选择器有哪些</strong></p>\n<ol>\n<li><code>*</code>通用选择器：选择所有的元素，不参与计算优先级，兼容IE6+</li>\n<li><code>#id</code>id选择器：选择id值为id的元素，兼容性IE6+</li>\n<li><code>.X</code>类选择器：选择class包含x的元素，兼容性IE6+</li>\n<li><code>X Y</code>后代选择器：选择满足x选择器的后代节点中满足Y选择器的元素；兼容IE6+</li>\n<li><code>tag name</code>元素选择器：选择所有标签为x的元素；兼容IE6</li>\n<li><code>.link, :visited, :focus, :hover, :active</code>选择特定状态的链接元素，兼容IE4+</li>\n<li><code>X+Y</code>直接兄弟选择器：在x之后的第一个兄弟节点中选择满足Y选择器的元素，兼容IE7+</li>\n<li><code>X&gt;Y</code>子选择器：选择x的子元素中满足y选择器的元素，兼容IE7</li>\n<li><code>X~Y</code>兄弟选择器：选择x之后的所有兄弟节点中满足x选择器的元素，兼容性IE7+</li>\n<li>[attr]：选择所有设置了attr属性的元素，兼容IE7</li>\n<li>[attr=value]：选择属性值刚好等于value的元素</li>\n<li>[attr~=value]：选择属性值刚好为空白符分隔，其中一个值刚好是value的元素</li>\n<li>[attr|=value]：选择属性值刚好为value或者value开头的元素</li>\n<li>[attr^=value]：选择属性值以value开头的元素</li>\n<li>[attr$=value]：选择属性值以value结尾的元素</li>\n<li>[attr=value]*：选择属性值中包包含value的元素</li>\n<li>[:checked]：选择单选框、复选框、下拉框中选中状态下的元素，兼容IE9+</li>\n<li><code>X:after， x::after</code>：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），css3中<code>::</code>表示伪元素。兼容性：<code>:after</code>为IE8+<code>::after</code>为IE9+</li>\n<li><code>:hover</code>：鼠标移入状态的元素，兼容性a标签IE4+，所有元素IE7+</li>\n<li><code>:not(selector)</code>：选择不符合selector的元素。不参与计算优先级，兼容IE9+</li>\n<li><code>::first-letter</code>:伪元素，选择块元素的第一行的第一个字母。兼容IE5.5+</li>\n<li><code>::first-line</code>：伪元素，选择块元素的第一行；兼容性IE5.5+</li>\n<li><code>:nth-child(an+b)</code>：伪类，选择前边有an+b-1个兄弟节点的元素，其中n&gt;=0，兼容性IE9+</li>\n<li><code>:nth-last-child(an+b)</code>：伪类，选择后边有an+b-1个兄弟节点的元素，其中n&gt;=0，兼容性IE9+</li>\n<li><code>X:nth-of-type(an+b)</code>：伪类，X为选择器，解析得到的元素标签，选择前边有an+b-1个相同标签兄弟节点的元素；兼容性IE9+</li>\n<li><code>X:nth-last-of-type(an+b)</code>：伪类，x为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟的元素；兼容性IE9+</li>\n<li><code>X:first-child</code>：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的第一个子元素。兼容IE7+</li>\n<li><code>X:last-child</code>：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的最后一个子元素。兼容IE9+</li>\n<li><code>X:only-child</code>：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容IE9+</li>\n<li><code>X:only-of-type</code>：伪类，选择x选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点是选中它，兼容性IE9+</li>\n<li><p><code>X：first-of-type</code>：伪类，选择X选择的元素，解析得到元素标签，如果该元素此类型元素的第一个元素，选中它；兼容IE9+</p>\n</li>\n<li><p><strong>css sprite是什么，有什么优缺点</strong></p>\n</li>\n</ol>\n<p>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案</p>\n<p><strong>优点</strong></p>\n<pre><code>1. 减少HTTP请求，极大的提高页面的加载速度\n2. 增加图片信息重复度，提高压缩比，减小图片大小\n3. 更换风格方便；只需在一张或者几张图片上修改颜色或者样式即可实现\n</code></pre><p><strong>缺点</strong></p>\n<pre><code>1. 图片合并麻烦\n2. 维护麻烦，修改一个图片可能需要从新布局整个图片样式\n</code></pre></li>\n<li><p><strong>display：none;与visibility：hidden</strong>的区别</p>\n<p>他们都是让元素不可见；区别</p>\n<ol>\n<li>display:none;会让元素完全从渲染树中消失，渲染的时候不占用任何空间；visibility:hidden不会让元素从渲染树中消失，设置该属性的元素会继续占用空间；只是内容不可见</li>\n<li>display:none是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden是继承属性；子孙节点的消失是继承了hidden属性值；通过设置<code>visibility:visible</code>可以让子孙节点显示</li>\n<li>修改常规流中元素的display通常会造成文档重排。修改visibility只会引起本元素的重绘</li>\n<li><p>读屏器不会读取设置display:none属性值的内容，会读取visibility:hidden元素内容</p>\n</li>\n<li><p><strong>css hack原理及常用的hack技术</strong></p>\n</li>\n</ol>\n<p>原理:利用不同浏览器对css的支持和解析结果不一样编写针对特定浏览器样式；常见的hack样式（1）属性hack（2）选择器hack（3）IE条件注释</p>\n<ul>\n<li><p>IE条件注释:适用于IE5-IE9,常见的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if IE 6]&gt;</span><br><span class=\"line\">Special instructions for IE 6 here</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>选择器hack:不同浏览器对选择器的支持不一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***** Selector Hacks ******/</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6 and below */</span><br><span class=\"line\">* html #uno  &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7 */</span><br><span class=\"line\">*:first-child+html #dos &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7, FF, Saf, Opera  */</span><br><span class=\"line\">html&gt;body #tres &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE8, FF, Saf, Opera (Everything but IE 6,7) */</span><br><span class=\"line\">html&gt;/**/body #cuatro &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Opera 9.27 and below, safari 2 */</span><br><span class=\"line\">html:first-child #cinco &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2-3 */</span><br><span class=\"line\">html[xmlns*=&quot;&quot;] body:last-child #seis &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class=\"line\">body:nth-of-type(1) #siete &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class=\"line\">body:first-of-type #ocho &#123;  color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* saf3+, chrome1+ */</span><br><span class=\"line\">@media screen and (-webkit-min-device-pixel-ratio:0) &#123;</span><br><span class=\"line\"> #diez  &#123; color: red  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* iPhone / mobile webkit */</span><br><span class=\"line\">@media screen and (max-device-width: 480px) &#123;</span><br><span class=\"line\"> #veintiseis &#123; color: red  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2 - 3.1 */</span><br><span class=\"line\">html[xmlns*=&quot;&quot;]:root #trece  &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2 - 3.1, Opera 9.25 */</span><br><span class=\"line\">*|html[xmlns*=&quot;&quot;] #catorce &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Everything but IE6-8 */</span><br><span class=\"line\">:root *&gt; #quince &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7 */</span><br><span class=\"line\">*+html #dieciocho &#123;  color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Firefox only. 1+ */</span><br><span class=\"line\">#veinticuatro,  x:-moz-any-link  &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Firefox 3.0+ */</span><br><span class=\"line\">#veinticinco,  x:-moz-any-link, x:default  &#123; color: red  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性hack:不同浏览器解析bug或方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* IE6 */</span><br><span class=\"line\">#once &#123; _color: blue &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7 */</span><br><span class=\"line\">#doce &#123; *color: blue; /* or #color: blue */ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Everything but IE6 */</span><br><span class=\"line\">#diecisiete &#123; color/**/: blue &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7, IE8 */</span><br><span class=\"line\">#diecinueve &#123; color: blue\\9; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7, IE8 */</span><br><span class=\"line\">#veinte &#123; color/*\\**/: blue\\9; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7 -- acts as an !important */</span><br><span class=\"line\">#veintesiete &#123; color: blue !ie; &#125; /* string after ! can be anything */</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>specified value,computed value,use value计算方法</strong></li>\n</ol>\n<ul>\n<li>specified value：计算方法如下：<ul>\n<li>如果样式表设置了一个值；使用这个值</li>\n<li>如果没有设置值；这个属性是继承属性，从父元素继承</li>\n<li>如果没有设置值且没有继承；则使用css属性规范指定的初始值</li>\n</ul>\n</li>\n<li>computed value：以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，computed value的主要作用是用于继承</li>\n<li>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值的单位为元素；以下属性依赖于布局<ul>\n<li>background-position</li>\n<li>bottom,left,right,top</li>\n<li>height,width</li>\n<li>margin值,padding值</li>\n<li>min-height,min-width</li>\n<li>text-indent</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>link与@import的区别</strong></p>\n<ol>\n<li>link是HTML方式，@import是css方式</li>\n<li>link最大限度支持并行下载，@import过多嵌套导致串行下载，</li>\n<li>link可以通过rel=“alternate stylesheet”指定候选样式</li>\n<li>浏览器支持link早于@import，可以使用@import对老浏览器隐藏样式</li>\n<li>@import必须在样式规则之前；可以在css文件中引用其他文件</li>\n</ol>\n</li>\n<li><p><strong><code>display:block</code>和<code>display:inline</code>的区别</strong></p>\n<ol>\n<li>block元素特点<br>处于常规流中，如果<code>width</code>没有设置，会自动填充满父容器；可以使用margin、padding值；在没有设置高度的情况下会扩展高度以包含常规流中的子元素；处于常规流中布局时在前后元素位置之间独立；忽略<code>vertical-align:inline</code>元素特点</li>\n<li>inline元素特点<br>水平方向上根据direction依次布局；不会在元素前后进行换行；受<code>white-space</code>控制；使用margin、padding在竖直方向无效；width/height属性对非替换行内元素无效，宽度由元素内容决定；非替换元素的行框高由line-height确定，替换行呢元素的行框高由height，margin，padding，border决定；浮动或绝对定位时会转化为block；vertical-align属性无效</li>\n</ol>\n</li>\n<li><p><strong>PNG,GIF,JPG格式的区别及如何选择</strong></p>\n<ol>\n<li>gif</li>\n</ol>\n<ul>\n<li>8位像素，256色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持boolean透明</li>\n<li>适合简单动画</li>\n</ul>\n<ol start=\"2\">\n<li>JPEG</li>\n</ol>\n<ul>\n<li>颜色限于256</li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n<ol start=\"3\">\n<li>PNG</li>\n</ol>\n<ul>\n<li>有PNG8和trueColorPNG</li>\n<li>png8类似GIF颜色上线为256，文件小，支持alpha透明，无动画</li>\n<li>适合图标，背景，按钮</li>\n</ul>\n</li>\n<li><p><strong>css有哪些继承属性</strong></p>\n</li>\n</ol>\n<ul>\n<li>font-size、font-color、font-family</li>\n<li>word-break</li>\n<li>letter-spacing</li>\n<li>text-align</li>\n<li>line-height</li>\n<li>color</li>\n<li>visibility</li>\n<li>cursor</li>\n</ul>\n<ol start=\"10\">\n<li><p><strong>IE6浏览器有哪些常见的bug，缺陷或者与标准不一致的地方；如何解决</strong></p>\n<ol>\n<li>IE6不支持line-height;解决方法使用css hack</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.target &#123;</span><br><span class=\"line\">    min-height: 100px;</span><br><span class=\"line\">    height: auto !important;</span><br><span class=\"line\">    height: 100px;   // IE6下内容高度超过会自动扩展高度</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p><code>ol&gt;li</code>的序号全为1，不递增；解决方法：为<code>li</code>设置样式<code>display:list-item</code>;</p>\n</li>\n<li><p>未定位父元素<code>overflow:auto</code>,包含<code>position:relative</code>子元素，子元素高于父元素时会溢出。解决方法：（1）子元素去掉定位属性（2）不能为子元素去掉定位时；父元素<code>position:relative</code></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">.outer &#123;</span><br><span class=\"line\">    width: 215px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    border: 1px solid red;</span><br><span class=\"line\">    overflow: auto;</span><br><span class=\"line\">    position: relative;  /* 修复bug */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.inner &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background-color: purple;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;outer&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>IE6只支持a标签的<code>:hover</code>伪类，解决方法：使用js为元素添加监听mouseenter、mouseleave事件</p>\n</li>\n<li><p>IE5-IE8不支持<code>opacity</code>,解决方法：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.opacity &#123;</span><br><span class=\"line\">    opacity: 0.4</span><br><span class=\"line\">    filter: alpha(opacity=60); /* for IE5-7 */</span><br><span class=\"line\">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li><p>IE6在设置height小于font-size时高度为font-size；解决方法：font-size：0</p>\n</li>\n<li><p>IE6不支持PNG透明背景；解决方法；IE6下使用gif图片</p>\n</li>\n<li><p>IE6-7不支持display：inline-block解决办法：设置inline并处罚hasLayout</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br><span class=\"line\">*display: inline;</span><br><span class=\"line\">*zoom: 1;</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li><p>IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决方法：（1）使用padding控制间距（2）浮动元素<code>display:inline</code>这样解决问题无任何副作用；css标准规定浮动元素会自动转为block</p>\n</li>\n<li><p>通过为块级元素设置宽度和左右margin值为auto时；IE6不能实现水平居中；解决方法，为父元素设置<code>text-align:center</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>容器包含若干浮动元素时如何清理浮动</strong></p>\n<ol>\n<li><p>容器元素闭合标签前添加额外元素并设置clear：both属性</p>\n</li>\n<li><p>父元素触发块级格式化上下文</p>\n</li>\n<li><p>设置容器元素伪元素进行清理</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 在标准浏览器下使用</span><br><span class=\"line\">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class=\"line\">*   contenteditable属性时在清理浮动元素上下的空白</span><br><span class=\"line\">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class=\"line\">*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7</span><br><span class=\"line\">*   zoom: 1;一致</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:before,</span><br><span class=\"line\">.clearfix:after &#123;</span><br><span class=\"line\">    content: &quot; &quot;; /* 1 */</span><br><span class=\"line\">    display: table; /* 2 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:after &#123;</span><br><span class=\"line\">    clear: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* IE 6/7下使用</span><br><span class=\"line\">* 通过触发hasLayout实现包含浮动</span><br><span class=\"line\">**/</span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">    *zoom: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>如何创建块级格式化上下文，BFC有什么用</strong></p>\n</li>\n</ol>\n<p>创建规则：</p>\n<ol>\n<li>根元素</li>\n<li>浮动元素</li>\n<li>绝对定位元素</li>\n<li><code>display</code>取值为<code>inline-block,table-cell,table-caption,flex,inline-flex</code>之一的元素</li>\n<li><code>over</code>不是visible的元素</li>\n</ol>\n<p>作用：</p>\n<p>​    可以包含浮动元素，不被浮动元素覆盖，阻止父子元素的margin折叠</p>\n<ol start=\"13\">\n<li><p><strong>display，float，position的关系</strong></p>\n<ol>\n<li>如果display为none，那么position和float都不起作用</li>\n<li>否则，如果position值为absolute或者fixed；框就是定位的；float的计算值为none</li>\n<li>否则，如果float是不none；框是浮动的</li>\n</ol>\n</li>\n<li><p><strong>外边距折叠</strong></p>\n</li>\n</ol>\n<p>毗邻的两个或者多个margin会合并成一个margin；叫做外边距折叠。规则如下：</p>\n<pre><code>1. 两个或者多个毗邻的普通流中块元素垂直方向的margin值折叠\n2. 浮动元素、inline-block元素、绝对定位元素的margin值不会和垂直方向的其他元素的margin折叠\n3. 创建了块级格式化上下文的元素，不会和他的子元素发生margin折叠\n4. 元素自身的margin-bottom和margin-top相邻时也会折叠\n</code></pre><ol start=\"15\">\n<li><p><strong>如何确定一个元素的包含块</strong></p>\n<ol>\n<li>根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同；对于paged media，他的尺寸等于page area。初始包含块的direction属性与根元素相同</li>\n<li><code>position</code>为<code>relative</code>或者<code>static</code>的元素；他的包含块由最近的块级（display为block/list-item/table）祖先元素到内容框组成</li>\n<li>如果元素position为fixed。对于连续媒体；它的包含块为viewport；对于paged media；包含块为page area</li>\n<li>如果元素的position为absolute；它的包含块由祖先元素中祖先元素中最近一个position为relative、absolute、或者fixed的元素产生；如果找不到定位的元素；包含块为初始包含块</li>\n</ol>\n</li>\n<li><p><strong>如何水平居中一个元素</strong></p>\n<ol>\n<li>如果需要居中</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前端知识点总结\"><a href=\"#前端知识点总结\" class=\"headerlink\" title=\"前端知识点总结\"></a>前端知识点总结</h2><h3 id=\"HTML，HTTP-web综合部分\"><a href=\"#HTML，HTTP-web综合部分\" class=\"headerlink\" title=\"HTML，HTTP,web综合部分\"></a>HTML，HTTP,web综合部分</h3><ol>\n<li><p>HTML是一种标记语言；不是编程语言；HTML的标签通常由开始标签和闭合标签，</p>\n</li>\n<li><p><strong>HTML5新增的语义元素</strong></p>\n<p>| header  |    定义文档或节的页眉    |<br>| :—–: | :————-: |<br>|   nav   |    定义导航链接的容器    |<br>| section |     定义文档中的节     |<br>| article |   定义独立的自包含文章    |<br>|  aside  | 定义内容之外的内容（比如侧栏） |<br>| footer  |    定义文档或节的页脚    |<br>| details |     定义额外的细节     |<br>| summary | 定义details元素的标题  |</p>\n</li>\n<li><p>常见的排序算法和时间复杂度、空间复杂度。参考图片<a href=\"https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png\" target=\"_blank\" rel=\"noopener\">https://github.com/qiu-deqing/FE-interview/blob/master/img/sort-compare.png</a></p>\n</li>\n<li><p><strong>前端需要注意哪些SEO</strong></p>\n<ol>\n<li>合理的title、description、keywords：搜索对这三项的权重逐渐减小；title强调重点即可；重要的关键词不要超过2次；description把页面高度概括；长度合适；keywords列举出重要关键词即可</li>\n<li>语义化HTML代码，符合W3C规范</li>\n<li>重要的HTML代码放在最前边</li>\n<li>重要内容不要用js输出；爬虫不会执行js获取内容</li>\n<li>非装饰性图片必须加alt</li>\n<li>提高网站速度</li>\n<li>少用iframe</li>\n</ol>\n</li>\n<li><p><strong>web开发中会话跟踪的方法</strong></p>\n<ol>\n<li>cookie：document.cookie = name + “=” + escape(value) + “;expires=”+过期时间（毫秒） + “;path=/“;（作用域）</li>\n<li>session</li>\n<li>url重写</li>\n<li>隐藏input</li>\n<li>ip地址</li>\n</ol>\n</li>\n<li><p><strong>img标签的title和alt的区别 </strong></p>\n<ol>\n<li>title是global attributes之一，用于为元素提供附加的advisory infomation。通常鼠标移动到元素上的时候显示。</li>\n<li>alt是img标签的特有属性；是图片内容的描述信息；提高图片的可访问性</li>\n</ol>\n</li>\n<li><p><strong>doctype是什么，常见的doctype及特点</strong></p>\n<ol>\n<li><p>&lt;!docutype&gt;是文档声明。声明必须处于HTML文档的头部，在html文档之前，html5不区分大小写</p>\n</li>\n<li><p>文档声明不是一个Html标签，是一个用于告诉浏览器当前html版本的指令</p>\n</li>\n<li><p>现代浏览器的html布局通是通过引擎检查doctype决定使用兼容模式还是标准模式对文档进行渲染</p>\n</li>\n<li><p>在html 4.01中doctype声明时指向一个DTD;HTML4.01基于SGML，所以DTD指定了标记规则保证浏览器能够正确渲染。html5不是基于SGML的；因此不用指定DTD</p>\n<p><strong>常见的doctype</strong></p>\n</li>\n</ol>\n<ul>\n<li><strong>HTML4.01 strict</strong>：不允许使用表现性、废弃元素（如font）以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></li>\n<li><strong>HTML4.01 Transitional</strong>:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></li>\n<li><strong>HTML4.01 Frameset</strong>:允许表现性元素，废气元素以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></li>\n<li><strong>XHTML1.0 Strict</strong>:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></li>\n<li><strong>XHTML1.0 Transitional</strong>:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： <code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></li>\n<li><strong>XHTML 1.0 Frameset</strong>:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></li>\n<li><strong>HTML 5</strong>: <code>&lt;!doctype html&gt;</code></li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>HTML全局属性（Global attribute）有哪些</strong></p>\n<ol>\n<li>accesskey:设置快捷键，提供快速访问元素</li>\n<li>class：为元素设置类标示，多个类名用空格隔开</li>\n<li>contenteditable：指定元素的内容是否可编辑</li>\n<li>contextMenu：自定义鼠标右键弹出菜单内容</li>\n<li>data-*：为元素增加自定义属性</li>\n<li>dir：设置元素文本fangxiang</li>\n<li>dragable：设置元素是否可拖拽</li>\n<li>hidden：表示一个文档是否在文档上显示</li>\n<li>id：元素id，文档内唯一</li>\n<li>lang：元素内容的语言</li>\n<li>spellcheck：是否启动拼写和语法检查</li>\n<li>style：行内css样式</li>\n<li>tabindex：设置元素可以获得焦点；通过tab可以导航</li>\n<li>title：元素相关的建议信息</li>\n<li>translate：元素和子孙节点内容是否本地化</li>\n</ol>\n</li>\n<li><p><strong>什么是web语义化，有什么好处</strong></p>\n<p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML的语义化是指–通过使用语义化的标签恰当的表示文档结构<br>css的语义化是指–为HTML的标签添加有意义的class，id补充未表达的语义；<br><strong>语义化的好处</strong> ：</p>\n<ul>\n<li>去掉样式后页面呈现清晰的解构</li>\n<li>盲人使用读屏器更好的阅读</li>\n<li>搜索引擎更好地理解页面；有利于收录</li>\n<li>便团队项目的可持续运作及维护</li>\n</ul>\n</li>\n<li><p><strong>HTTP method</strong></p>\n<ol>\n<li>一台服务器要与HTTP1.1兼容，只要为资源实现get和HEAD方法即可</li>\n<li>GET是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong>。</li>\n<li>HEAD与GET类似，但<strong>服务器在响应中值返回首部，不返回实体的主体部分</strong></li>\n<li>PUT让服务器<strong>用请求的主体部分来创建一个由所请求的URL命名的新文档，或者如果那个URL已经存在的话，就用这个主体代替它</strong></li>\n<li>POST起初是用来向服务器输入数据的。实际上通常会用它来支持HTML的表单，表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方</li>\n<li>TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹一个TRACE响应并在响应主题中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS方法请求web服务器告知其支持的各种功能，可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE请求服务器删除请求URL指定的资源</li>\n</ol>\n</li>\n<li><p><strong>从浏览器地址栏输入URL到显示页面的步骤(以HTTP为例）</strong></p>\n<ol>\n<li><p>在浏览器输入URL</p>\n</li>\n<li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>\n<ul>\n<li>如果资源未缓存，发起新请求</li>\n<li>如果已缓存，检验是否过期，未过期直接供给客户端，否则与服务器进行验证</li>\n<li>检查是否过期通常由两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>:<ul>\n<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存失效时间</li>\n<li>HTTP1.1增加了cache-Control:max-age=;值是以秒为单位的最大过期时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>浏览器解析URL获取协议、主机、端口、路径</p>\n</li>\n<li><p>浏览器组装一个HTTP（GET）请求报文</p>\n</li>\n<li><p>浏览器获取主机IP地址。过程如下：</p>\n<ul>\n<li>浏览器缓存</li>\n<li>本机缓存</li>\n<li>hosts文件</li>\n<li>路由器缓存</li>\n<li>ISP DNS缓存</li>\n<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>\n</ul>\n</li>\n<li><p>打开一个socket与目标ip地址，端口建立TCP连接，三次握手如下</p>\n<ul>\n<li>客户端发送一个TCP的SYN=1，Seq=x的包到服务器端口</li>\n<li>服务器发回SYN=1，ACK=x+1，Seq=y的响应包</li>\n<li>客户端发送ACK=Y+1，Seq=Z</li>\n</ul>\n</li>\n<li><p>TCP连接建立后发送HTTP请求</p>\n</li>\n<li><p>服务器接收请求并解析，将请求转发到服务器程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p>\n</li>\n<li><p>服务器检查HTTP请求是否包含缓存验证信息，如果验证缓存未过期，返回304等对应状态码</p>\n</li>\n<li><p>处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作</p>\n</li>\n<li><p>服务器将相应报文通过TCP连接发送回浏览器</p>\n</li>\n<li><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用。关闭TCP连接的四次握手如下：</p>\n<ul>\n<li>主动方发送Fin=1，Ack=Z，Seq=X报文</li>\n<li>被动方发送ACK=X+1，Seq=Z报文</li>\n<li>被动发发送Fin=1，ACK=X，Seq=Y报文</li>\n<li>主动方发送ACK=Y,Seq=X报文</li>\n</ul>\n</li>\n<li><p>浏览器检查响应状态码：是否为1XX,3XX,4XX,5XX这些情况处理与2XX不同</p>\n</li>\n<li><p>如果资源可缓存，进行缓存</p>\n</li>\n<li><p>对响应进行解码</p>\n</li>\n<li><p>根据资源的类型决定如何处理</p>\n</li>\n<li><p>解析HTML,构建DOM树，下载资源，构建cssDom树，执行js脚本，这些操作没有严格的先后顺序</p>\n</li>\n<li><p>构建DOM树</p>\n<ul>\n<li>Tokenizing：根据HTML规范将字符流解析为标记</li>\n<li>lexing：词法分析将标记转换为对象定义属性和规则</li>\n<li>DOM construction：根据HTML标记关系将对象组成Dom树</li>\n</ul>\n</li>\n<li><p>解析过程中遇到图片、样式表、js文件，启动下载</p>\n</li>\n<li><p>构建cssDom树</p>\n<ul>\n<li>从DOM树的根节点遍历所有的可见节点，不可见节点包括：(1)<code>script</code>和<code>meta</code>标签 (2)被css隐藏的节点</li>\n<li>对每一个可见节点，找到恰当的cssDom并应用</li>\n<li>发布可视节点的内容和计算样式</li>\n</ul>\n</li>\n<li><p>js解析如下;</p>\n<ol>\n<li>浏览器创建document对象并解析HTML，将解析到的元素和文本节点添加到文档中。此时document.readystate为loading</li>\n<li>HTML遇到没有async和defer的script时；将他们添加到文档中然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停</li>\n<li>当解析器遇到设置了async属性的script时；开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行；但是解析器不会停下来等它下载；异步脚本禁止使用document.write()</li>\n<li>当文档完成解析，document.readstate变成interactive</li>\n<li>所有defer脚本会按照在文档出现的顺序执行；延迟脚本嫩访问完整文档树；禁止使用document.write()</li>\n<li>浏览器在Document对象上触发DomContentLoaded事件</li>\n<li>此时文档完全解析完成；浏览器可能还在等待图片等内容加载；等这些内容完成载入并且所有异步脚本载入和执行。document.readyState状态变为complete。window触发load事件</li>\n<li>显示页面</li>\n</ol>\n</li>\n<li><p><strong>http request报文解构</strong></p>\n<ol>\n<li><p>首行是Request-Line包括：请求方法、请求URI、协议版本、CRLF</p>\n</li>\n<li><p>首行之后是若干行请求头，包括general-header、request-header或者entity-header，每一行以CRLF结束</p>\n</li>\n<li><p>请求头和消息实体之间有一个CRLF分隔、</p>\n</li>\n<li><p>根据实际请求需要可能包含一个消息实体；一个请求报文例子如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1</span><br><span class=\"line\">Host: www.w3.org</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</span><br><span class=\"line\">Referer: https://www.google.com.hk/</span><br><span class=\"line\">Accept-Encoding: gzip,deflate,sdch</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class=\"line\">Cookie: authorstyle=yes</span><br><span class=\"line\">If-None-Match: &quot;2cc8-3e3073913b100&quot;</span><br><span class=\"line\">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">name=qiu&amp;age=25</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>HTTP response报文结构是怎样的</strong></p>\n<ol>\n<li><p>行首的状态行包括：<strong>HTTP版本，状态码，状态描述，</strong>后边跟一个CRLF</p>\n</li>\n<li><p>行首之后是若干行响应头，<strong>包括：通用头部，响应头部，实体头部</strong></p>\n</li>\n<li><p>响应头部和响应实体之间用一个CRLF空行分隔</p>\n</li>\n<li><p>最后是一个可能的消息实体；响应报文例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Tue, 08 Jul 2014 05:28:43 GMT</span><br><span class=\"line\">Server: Apache/2</span><br><span class=\"line\">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class=\"line\">ETag: &quot;40d7-3e3073913b100&quot;</span><br><span class=\"line\">Accept-Ranges: bytes</span><br><span class=\"line\">Content-Length: 16599</span><br><span class=\"line\">Cache-Control: max-age=21600</span><br><span class=\"line\">Expires: Tue, 08 Jul 2014 11:28:43 GMT</span><br><span class=\"line\">P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;</span><br><span class=\"line\">Content-Type: text/html; charset=iso-8859-1</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p><strong>如何进行网站性能优化</strong></p>\n<ul>\n<li>content方面<ol>\n<li>减少HTTP请求：合并文件，图标类文件或复用小图使用精灵图，</li>\n<li>减少DNS查询：DNS查询之前浏览器不能从这个主机下载任何文件。方法：DNS缓存、将资源分不到恰当数量的主机名</li>\n<li>避免重定向；使ajax可缓存</li>\n<li>非必须组件采用延迟加载；未来所需组件预加载</li>\n<li>减少DOM元素数量</li>\n<li>将资源放在不同的域下：浏览器同时从同一个域下下载的资源有限；增加域可以提高并行下载量</li>\n<li>减少iframe数量</li>\n<li>不要出现404</li>\n</ol>\n</li>\n<li>server方面<ol>\n<li>使用CDN</li>\n<li>添加Expires或者Cache-Control响应头</li>\n<li>对组件使用Gzip压缩</li>\n<li>配置Etag</li>\n<li>ajax使用get请求</li>\n<li>避免空src的请标签</li>\n</ol>\n</li>\n<li>cookie方面<ol>\n<li>减小cookie大小</li>\n<li>引入资源的域名不要包含cookie</li>\n</ol>\n</li>\n<li>css方面<ol>\n<li>将样式表放到页面顶部</li>\n<li>不使用css样式表</li>\n<li>不使用@import！</li>\n<li>不使用IE的filter</li>\n</ol>\n</li>\n<li>js方面<ol>\n<li>将脚本放入页面的底部</li>\n<li>将js和css从外部引入</li>\n<li>压缩js和css；删除不需要的脚本</li>\n<li>减少DOM访问</li>\n<li>合理设计事件监听器</li>\n</ol>\n</li>\n<li>图片方面<ol>\n<li>优化图片：根据实际颜色需要选择色深、压缩</li>\n<li>优化css精灵</li>\n<li>不要在HTML中拉伸图片</li>\n<li>保证favicon.icon小并且可缓存</li>\n</ol>\n</li>\n<li>移动方面<ol>\n<li>保证组件小于25k</li>\n<li>pack component into a Multipart Document 将项目分为多个组件</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>什么是渐进增强</strong></p>\n<p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能；同时为高级浏览器和高宽带用户提供良好的用户体验。核心原则如下：</p>\n<ul>\n<li>所有浏览器都必须能访问基本内容</li>\n<li>所有浏览器都必须能使用基本功能</li>\n<li>所有内容都包含在语义化标签中</li>\n<li>通过外部css提供增强布局</li>\n<li>通过非侵入式、外部js提供增强功能</li>\n<li>终端用户web浏览器的个人偏好</li>\n</ul>\n</li>\n<li><p><strong>HTTP状态码及其含义</strong></p>\n<ol>\n<li>1XX：信息状态码<ul>\n<li>100 Continue:客户端应当继续发请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且未被拒绝</li>\n<li>101：服务器已经理解客户端的请求</li>\n</ul>\n</li>\n<li>2XX：成功状态码<ul>\n<li>200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回</li>\n<li>201 Create：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出他的URL。</li>\n<li>202 Accepted;请求正在被执行，但还没有处理完</li>\n<li>203 Non-Authoritative Information:</li>\n<li>204 No Content ; </li>\n<li>205 Reset Content</li>\n<li>Partial Content</li>\n</ul>\n</li>\n<li>3XX : 重定向<ul>\n<li>300 Multiple Choice : 表示请求的文档可以在多个地方找到，并将在返回的文档中列出来；如果服务器有首选设置；首选项将会被列于定位响应头的信息中</li>\n<li>301 Moved Permanently 请求的文档在别的地方；文档新的URL会在定位响应头中给出。浏览器会自动连接到新的URL</li>\n<li>302 Found 与301类似，只是定位信息中所给的URL是临时地址；而不是永久的改变地址</li>\n<li>303 see Other</li>\n<li>304 Not Modified</li>\n<li>305 Use Proxy</li>\n<li>306 </li>\n<li>307  Temporary Redirect</li>\n</ul>\n</li>\n<li>4XX<ul>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>402 Payment Required</li>\n<li>403 Forbidden</li>\n<li>404 Not Found</li>\n<li>405 Method Not Allowed</li>\n</ul>\n</li>\n<li>5XX<ul>\n<li>500 Internal Server Error</li>\n<li>501 Not Implemented</li>\n<li>502 Bad Gateway</li>\n<li>503 Service Unavailable</li>\n<li>504 GateWay Timeout</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"css选择部分\"><a href=\"#css选择部分\" class=\"headerlink\" title=\"css选择部分\"></a>css选择部分</h3><ol>\n<li><p><strong>CSS选择器有哪些</strong></p>\n<ol>\n<li><code>*</code>通用选择器：选择所有的元素，不参与计算优先级，兼容IE6+</li>\n<li><code>#id</code>id选择器：选择id值为id的元素，兼容性IE6+</li>\n<li><code>.X</code>类选择器：选择class包含x的元素，兼容性IE6+</li>\n<li><code>X Y</code>后代选择器：选择满足x选择器的后代节点中满足Y选择器的元素；兼容IE6+</li>\n<li><code>tag name</code>元素选择器：选择所有标签为x的元素；兼容IE6</li>\n<li><code>.link, :visited, :focus, :hover, :active</code>选择特定状态的链接元素，兼容IE4+</li>\n<li><code>X+Y</code>直接兄弟选择器：在x之后的第一个兄弟节点中选择满足Y选择器的元素，兼容IE7+</li>\n<li><code>X&gt;Y</code>子选择器：选择x的子元素中满足y选择器的元素，兼容IE7</li>\n<li><code>X~Y</code>兄弟选择器：选择x之后的所有兄弟节点中满足x选择器的元素，兼容性IE7+</li>\n<li>[attr]：选择所有设置了attr属性的元素，兼容IE7</li>\n<li>[attr=value]：选择属性值刚好等于value的元素</li>\n<li>[attr~=value]：选择属性值刚好为空白符分隔，其中一个值刚好是value的元素</li>\n<li>[attr|=value]：选择属性值刚好为value或者value开头的元素</li>\n<li>[attr^=value]：选择属性值以value开头的元素</li>\n<li>[attr$=value]：选择属性值以value结尾的元素</li>\n<li>[attr=value]*：选择属性值中包包含value的元素</li>\n<li>[:checked]：选择单选框、复选框、下拉框中选中状态下的元素，兼容IE9+</li>\n<li><code>X:after， x::after</code>：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），css3中<code>::</code>表示伪元素。兼容性：<code>:after</code>为IE8+<code>::after</code>为IE9+</li>\n<li><code>:hover</code>：鼠标移入状态的元素，兼容性a标签IE4+，所有元素IE7+</li>\n<li><code>:not(selector)</code>：选择不符合selector的元素。不参与计算优先级，兼容IE9+</li>\n<li><code>::first-letter</code>:伪元素，选择块元素的第一行的第一个字母。兼容IE5.5+</li>\n<li><code>::first-line</code>：伪元素，选择块元素的第一行；兼容性IE5.5+</li>\n<li><code>:nth-child(an+b)</code>：伪类，选择前边有an+b-1个兄弟节点的元素，其中n&gt;=0，兼容性IE9+</li>\n<li><code>:nth-last-child(an+b)</code>：伪类，选择后边有an+b-1个兄弟节点的元素，其中n&gt;=0，兼容性IE9+</li>\n<li><code>X:nth-of-type(an+b)</code>：伪类，X为选择器，解析得到的元素标签，选择前边有an+b-1个相同标签兄弟节点的元素；兼容性IE9+</li>\n<li><code>X:nth-last-of-type(an+b)</code>：伪类，x为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟的元素；兼容性IE9+</li>\n<li><code>X:first-child</code>：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的第一个子元素。兼容IE7+</li>\n<li><code>X:last-child</code>：伪类，选择满足X选择器的元素，切这个元素是其父元素节点的最后一个子元素。兼容IE9+</li>\n<li><code>X:only-child</code>：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容IE9+</li>\n<li><code>X:only-of-type</code>：伪类，选择x选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点是选中它，兼容性IE9+</li>\n<li><p><code>X：first-of-type</code>：伪类，选择X选择的元素，解析得到元素标签，如果该元素此类型元素的第一个元素，选中它；兼容IE9+</p>\n</li>\n<li><p><strong>css sprite是什么，有什么优缺点</strong></p>\n</li>\n</ol>\n<p>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案</p>\n<p><strong>优点</strong></p>\n<pre><code>1. 减少HTTP请求，极大的提高页面的加载速度\n2. 增加图片信息重复度，提高压缩比，减小图片大小\n3. 更换风格方便；只需在一张或者几张图片上修改颜色或者样式即可实现\n</code></pre><p><strong>缺点</strong></p>\n<pre><code>1. 图片合并麻烦\n2. 维护麻烦，修改一个图片可能需要从新布局整个图片样式\n</code></pre></li>\n<li><p><strong>display：none;与visibility：hidden</strong>的区别</p>\n<p>他们都是让元素不可见；区别</p>\n<ol>\n<li>display:none;会让元素完全从渲染树中消失，渲染的时候不占用任何空间；visibility:hidden不会让元素从渲染树中消失，设置该属性的元素会继续占用空间；只是内容不可见</li>\n<li>display:none是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden是继承属性；子孙节点的消失是继承了hidden属性值；通过设置<code>visibility:visible</code>可以让子孙节点显示</li>\n<li>修改常规流中元素的display通常会造成文档重排。修改visibility只会引起本元素的重绘</li>\n<li><p>读屏器不会读取设置display:none属性值的内容，会读取visibility:hidden元素内容</p>\n</li>\n<li><p><strong>css hack原理及常用的hack技术</strong></p>\n</li>\n</ol>\n<p>原理:利用不同浏览器对css的支持和解析结果不一样编写针对特定浏览器样式；常见的hack样式（1）属性hack（2）选择器hack（3）IE条件注释</p>\n<ul>\n<li><p>IE条件注释:适用于IE5-IE9,常见的格式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if IE 6]&gt;</span><br><span class=\"line\">Special instructions for IE 6 here</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>选择器hack:不同浏览器对选择器的支持不一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***** Selector Hacks ******/</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6 and below */</span><br><span class=\"line\">* html #uno  &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7 */</span><br><span class=\"line\">*:first-child+html #dos &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7, FF, Saf, Opera  */</span><br><span class=\"line\">html&gt;body #tres &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE8, FF, Saf, Opera (Everything but IE 6,7) */</span><br><span class=\"line\">html&gt;/**/body #cuatro &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Opera 9.27 and below, safari 2 */</span><br><span class=\"line\">html:first-child #cinco &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2-3 */</span><br><span class=\"line\">html[xmlns*=&quot;&quot;] body:last-child #seis &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class=\"line\">body:nth-of-type(1) #siete &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span><br><span class=\"line\">body:first-of-type #ocho &#123;  color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* saf3+, chrome1+ */</span><br><span class=\"line\">@media screen and (-webkit-min-device-pixel-ratio:0) &#123;</span><br><span class=\"line\"> #diez  &#123; color: red  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* iPhone / mobile webkit */</span><br><span class=\"line\">@media screen and (max-device-width: 480px) &#123;</span><br><span class=\"line\"> #veintiseis &#123; color: red  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2 - 3.1 */</span><br><span class=\"line\">html[xmlns*=&quot;&quot;]:root #trece  &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Safari 2 - 3.1, Opera 9.25 */</span><br><span class=\"line\">*|html[xmlns*=&quot;&quot;] #catorce &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Everything but IE6-8 */</span><br><span class=\"line\">:root *&gt; #quince &#123; color: red  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7 */</span><br><span class=\"line\">*+html #dieciocho &#123;  color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Firefox only. 1+ */</span><br><span class=\"line\">#veinticuatro,  x:-moz-any-link  &#123; color: red &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Firefox 3.0+ */</span><br><span class=\"line\">#veinticinco,  x:-moz-any-link, x:default  &#123; color: red  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性hack:不同浏览器解析bug或方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* IE6 */</span><br><span class=\"line\">#once &#123; _color: blue &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7 */</span><br><span class=\"line\">#doce &#123; *color: blue; /* or #color: blue */ &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Everything but IE6 */</span><br><span class=\"line\">#diecisiete &#123; color/**/: blue &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7, IE8 */</span><br><span class=\"line\">#diecinueve &#123; color: blue\\9; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE7, IE8 */</span><br><span class=\"line\">#veinte &#123; color/*\\**/: blue\\9; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* IE6, IE7 -- acts as an !important */</span><br><span class=\"line\">#veintesiete &#123; color: blue !ie; &#125; /* string after ! can be anything */</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>specified value,computed value,use value计算方法</strong></li>\n</ol>\n<ul>\n<li>specified value：计算方法如下：<ul>\n<li>如果样式表设置了一个值；使用这个值</li>\n<li>如果没有设置值；这个属性是继承属性，从父元素继承</li>\n<li>如果没有设置值且没有继承；则使用css属性规范指定的初始值</li>\n</ul>\n</li>\n<li>computed value：以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，computed value的主要作用是用于继承</li>\n<li>used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值的单位为元素；以下属性依赖于布局<ul>\n<li>background-position</li>\n<li>bottom,left,right,top</li>\n<li>height,width</li>\n<li>margin值,padding值</li>\n<li>min-height,min-width</li>\n<li>text-indent</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>link与@import的区别</strong></p>\n<ol>\n<li>link是HTML方式，@import是css方式</li>\n<li>link最大限度支持并行下载，@import过多嵌套导致串行下载，</li>\n<li>link可以通过rel=“alternate stylesheet”指定候选样式</li>\n<li>浏览器支持link早于@import，可以使用@import对老浏览器隐藏样式</li>\n<li>@import必须在样式规则之前；可以在css文件中引用其他文件</li>\n</ol>\n</li>\n<li><p><strong><code>display:block</code>和<code>display:inline</code>的区别</strong></p>\n<ol>\n<li>block元素特点<br>处于常规流中，如果<code>width</code>没有设置，会自动填充满父容器；可以使用margin、padding值；在没有设置高度的情况下会扩展高度以包含常规流中的子元素；处于常规流中布局时在前后元素位置之间独立；忽略<code>vertical-align:inline</code>元素特点</li>\n<li>inline元素特点<br>水平方向上根据direction依次布局；不会在元素前后进行换行；受<code>white-space</code>控制；使用margin、padding在竖直方向无效；width/height属性对非替换行内元素无效，宽度由元素内容决定；非替换元素的行框高由line-height确定，替换行呢元素的行框高由height，margin，padding，border决定；浮动或绝对定位时会转化为block；vertical-align属性无效</li>\n</ol>\n</li>\n<li><p><strong>PNG,GIF,JPG格式的区别及如何选择</strong></p>\n<ol>\n<li>gif</li>\n</ol>\n<ul>\n<li>8位像素，256色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持boolean透明</li>\n<li>适合简单动画</li>\n</ul>\n<ol start=\"2\">\n<li>JPEG</li>\n</ol>\n<ul>\n<li>颜色限于256</li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n<ol start=\"3\">\n<li>PNG</li>\n</ol>\n<ul>\n<li>有PNG8和trueColorPNG</li>\n<li>png8类似GIF颜色上线为256，文件小，支持alpha透明，无动画</li>\n<li>适合图标，背景，按钮</li>\n</ul>\n</li>\n<li><p><strong>css有哪些继承属性</strong></p>\n</li>\n</ol>\n<ul>\n<li>font-size、font-color、font-family</li>\n<li>word-break</li>\n<li>letter-spacing</li>\n<li>text-align</li>\n<li>line-height</li>\n<li>color</li>\n<li>visibility</li>\n<li>cursor</li>\n</ul>\n<ol start=\"10\">\n<li><p><strong>IE6浏览器有哪些常见的bug，缺陷或者与标准不一致的地方；如何解决</strong></p>\n<ol>\n<li>IE6不支持line-height;解决方法使用css hack</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.target &#123;</span><br><span class=\"line\">    min-height: 100px;</span><br><span class=\"line\">    height: auto !important;</span><br><span class=\"line\">    height: 100px;   // IE6下内容高度超过会自动扩展高度</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p><code>ol&gt;li</code>的序号全为1，不递增；解决方法：为<code>li</code>设置样式<code>display:list-item</code>;</p>\n</li>\n<li><p>未定位父元素<code>overflow:auto</code>,包含<code>position:relative</code>子元素，子元素高于父元素时会溢出。解决方法：（1）子元素去掉定位属性（2）不能为子元素去掉定位时；父元素<code>position:relative</code></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">.outer &#123;</span><br><span class=\"line\">    width: 215px;</span><br><span class=\"line\">    height: 100px;</span><br><span class=\"line\">    border: 1px solid red;</span><br><span class=\"line\">    overflow: auto;</span><br><span class=\"line\">    position: relative;  /* 修复bug */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.inner &#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background-color: purple;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;outer&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>IE6只支持a标签的<code>:hover</code>伪类，解决方法：使用js为元素添加监听mouseenter、mouseleave事件</p>\n</li>\n<li><p>IE5-IE8不支持<code>opacity</code>,解决方法：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.opacity &#123;</span><br><span class=\"line\">    opacity: 0.4</span><br><span class=\"line\">    filter: alpha(opacity=60); /* for IE5-7 */</span><br><span class=\"line\">    -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li><p>IE6在设置height小于font-size时高度为font-size；解决方法：font-size：0</p>\n</li>\n<li><p>IE6不支持PNG透明背景；解决方法；IE6下使用gif图片</p>\n</li>\n<li><p>IE6-7不支持display：inline-block解决办法：设置inline并处罚hasLayout</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br><span class=\"line\">*display: inline;</span><br><span class=\"line\">*zoom: 1;</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li><p>IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决方法：（1）使用padding控制间距（2）浮动元素<code>display:inline</code>这样解决问题无任何副作用；css标准规定浮动元素会自动转为block</p>\n</li>\n<li><p>通过为块级元素设置宽度和左右margin值为auto时；IE6不能实现水平居中；解决方法，为父元素设置<code>text-align:center</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>容器包含若干浮动元素时如何清理浮动</strong></p>\n<ol>\n<li><p>容器元素闭合标签前添加额外元素并设置clear：both属性</p>\n</li>\n<li><p>父元素触发块级格式化上下文</p>\n</li>\n<li><p>设置容器元素伪元素进行清理</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 在标准浏览器下使用</span><br><span class=\"line\">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class=\"line\">*   contenteditable属性时在清理浮动元素上下的空白</span><br><span class=\"line\">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class=\"line\">*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7</span><br><span class=\"line\">*   zoom: 1;一致</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:before,</span><br><span class=\"line\">.clearfix:after &#123;</span><br><span class=\"line\">    content: &quot; &quot;; /* 1 */</span><br><span class=\"line\">    display: table; /* 2 */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.clearfix:after &#123;</span><br><span class=\"line\">    clear: both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* IE 6/7下使用</span><br><span class=\"line\">* 通过触发hasLayout实现包含浮动</span><br><span class=\"line\">**/</span><br><span class=\"line\">.clearfix &#123;</span><br><span class=\"line\">    *zoom: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>如何创建块级格式化上下文，BFC有什么用</strong></p>\n</li>\n</ol>\n<p>创建规则：</p>\n<ol>\n<li>根元素</li>\n<li>浮动元素</li>\n<li>绝对定位元素</li>\n<li><code>display</code>取值为<code>inline-block,table-cell,table-caption,flex,inline-flex</code>之一的元素</li>\n<li><code>over</code>不是visible的元素</li>\n</ol>\n<p>作用：</p>\n<p>​    可以包含浮动元素，不被浮动元素覆盖，阻止父子元素的margin折叠</p>\n<ol start=\"13\">\n<li><p><strong>display，float，position的关系</strong></p>\n<ol>\n<li>如果display为none，那么position和float都不起作用</li>\n<li>否则，如果position值为absolute或者fixed；框就是定位的；float的计算值为none</li>\n<li>否则，如果float是不none；框是浮动的</li>\n</ol>\n</li>\n<li><p><strong>外边距折叠</strong></p>\n</li>\n</ol>\n<p>毗邻的两个或者多个margin会合并成一个margin；叫做外边距折叠。规则如下：</p>\n<pre><code>1. 两个或者多个毗邻的普通流中块元素垂直方向的margin值折叠\n2. 浮动元素、inline-block元素、绝对定位元素的margin值不会和垂直方向的其他元素的margin折叠\n3. 创建了块级格式化上下文的元素，不会和他的子元素发生margin折叠\n4. 元素自身的margin-bottom和margin-top相邻时也会折叠\n</code></pre><ol start=\"15\">\n<li><p><strong>如何确定一个元素的包含块</strong></p>\n<ol>\n<li>根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同；对于paged media，他的尺寸等于page area。初始包含块的direction属性与根元素相同</li>\n<li><code>position</code>为<code>relative</code>或者<code>static</code>的元素；他的包含块由最近的块级（display为block/list-item/table）祖先元素到内容框组成</li>\n<li>如果元素position为fixed。对于连续媒体；它的包含块为viewport；对于paged media；包含块为page area</li>\n<li>如果元素的position为absolute；它的包含块由祖先元素中祖先元素中最近一个position为relative、absolute、或者fixed的元素产生；如果找不到定位的元素；包含块为初始包含块</li>\n</ol>\n</li>\n<li><p><strong>如何水平居中一个元素</strong></p>\n<ol>\n<li>如果需要居中</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><h3 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjpdgsewe0000ybf70xjk7450","category_id":"cjpdgsewp0002ybf7epx9rndr","_id":"cjpdgsex4000bybf7qsmgzrjb"},{"post_id":"cjpdgsex00009ybf76bsmr10s","category_id":"cjpdgsewz0007ybf7psw936qr","_id":"cjpdgsex7000fybf7g069ur1v"},{"post_id":"cjpdgsewm0001ybf7iw74vhuu","category_id":"cjpdgsewz0007ybf7psw936qr","_id":"cjpdgsex8000jybf7mxg221nc"},{"post_id":"cjpdgsews0004ybf7nn90nyo1","category_id":"cjpdgsewz0007ybf7psw936qr","_id":"cjpdgsex9000kybf7ffdte5rk"},{"post_id":"cjpdgsewx0006ybf7z9byywaw","category_id":"cjpdgsex7000hybf7xlhwql9t","_id":"cjpdgsex9000nybf7esr0o58e"},{"post_id":"cjpdgsex2000aybf72mlvehvw","category_id":"cjpdgsex9000lybf7d3pwx6ie","_id":"cjpdgsexb000qybf751gqxpg5"}],"PostTag":[{"post_id":"cjpdgsewe0000ybf70xjk7450","tag_id":"cjpdgsewr0003ybf7onuwpj9e","_id":"cjpdgsex7000eybf747gpod9c"},{"post_id":"cjpdgsewe0000ybf70xjk7450","tag_id":"cjpdgsewz0008ybf7b0nk12k3","_id":"cjpdgsex7000gybf7frlcd9ok"},{"post_id":"cjpdgsewm0001ybf7iw74vhuu","tag_id":"cjpdgsex4000dybf78w0yvj6h","_id":"cjpdgsexa000pybf7cvlz9vk3"},{"post_id":"cjpdgsewm0001ybf7iw74vhuu","tag_id":"cjpdgsex8000iybf74x4fo18r","_id":"cjpdgsexb000rybf7zolthyql"},{"post_id":"cjpdgsewm0001ybf7iw74vhuu","tag_id":"cjpdgsex9000mybf7ha5o16ef","_id":"cjpdgsexb000tybf79i2jum6y"},{"post_id":"cjpdgsews0004ybf7nn90nyo1","tag_id":"cjpdgsex4000dybf78w0yvj6h","_id":"cjpdgsexd000wybf7wd5fl04d"},{"post_id":"cjpdgsews0004ybf7nn90nyo1","tag_id":"cjpdgsex8000iybf74x4fo18r","_id":"cjpdgsexd000xybf70hi8udbm"},{"post_id":"cjpdgsews0004ybf7nn90nyo1","tag_id":"cjpdgsex9000mybf7ha5o16ef","_id":"cjpdgsexe000zybf7d3evdy2o"},{"post_id":"cjpdgsewx0006ybf7z9byywaw","tag_id":"cjpdgsexc000vybf7q1iqlisk","_id":"cjpdgsexe0010ybf7sfba0a45"},{"post_id":"cjpdgsex00009ybf76bsmr10s","tag_id":"cjpdgsex4000dybf78w0yvj6h","_id":"cjpdgsexf0013ybf7btc5edfi"},{"post_id":"cjpdgsex00009ybf76bsmr10s","tag_id":"cjpdgsexe0011ybf72fbpa2rm","_id":"cjpdgsexf0014ybf77aiyv803"},{"post_id":"cjpdgsex2000aybf72mlvehvw","tag_id":"cjpdgsexe0012ybf7adu6m7uh","_id":"cjpdgsexf0015ybf7l9ifjtjx"}],"Tag":[{"name":"tool","_id":"cjpdgsewr0003ybf7onuwpj9e"},{"name":"hexo","_id":"cjpdgsewz0008ybf7b0nk12k3"},{"name":"js","_id":"cjpdgsex4000dybf78w0yvj6h"},{"name":"变量","_id":"cjpdgsex8000iybf74x4fo18r"},{"name":"作用域","_id":"cjpdgsex9000mybf7ha5o16ef"},{"name":"blob","_id":"cjpdgsexc000vybf7q1iqlisk"},{"name":"引用类型","_id":"cjpdgsexe0011ybf72fbpa2rm"},{"name":"html","_id":"cjpdgsexe0012ybf7adu6m7uh"}]}}